{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Splunk Solutions SDK is an open source packaged solution for getting data into Splunk using modular inputs. This SDK is used by Splunk Add-on builder, and Splunk UCC based add-ons and is intended for use by partner developers. This SDK/Library extends the Splunk SDK for Python.","title":"Home"},{"location":"#overview","text":"Splunk Solutions SDK is an open source packaged solution for getting data into Splunk using modular inputs. This SDK is used by Splunk Add-on builder, and Splunk UCC based add-ons and is intended for use by partner developers. This SDK/Library extends the Splunk SDK for Python.","title":"Overview"},{"location":"acl/","text":"This module contains interfaces that support CRUD operations on ACL. __all__ special \u00b6 ACLException ( Exception ) \u00b6 Exception raised by ACLManager. ACLManager \u00b6 ACL manager. Examples: >>> import solnlib.acl as sacl >>> saclm = sacl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> saclm . get ( 'data/transforms/extractions' ) >>> saclm . update ( 'data/transforms/extractions/_acl' , perms_read = [ '*' ], perms_write = [ '*' ]) __init__ ( self , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes ACLManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/acl.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes ACLManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , app , owner = owner , scheme = scheme , host = host , port = port , ** context ) get ( self , path ) \u00b6 Get ACL of /servicesNS/{ owner }/{ app }/{ path }. Parameters: Name Type Description Default path str Path of ACL relative to /servicesNS/{ owner }/{ app } required Returns: Type Description dict A dict contains ACL. Exceptions: Type Description ACLException If path is invalid. Examples: >>> aclm = acl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> perms = aclm . get ( 'data/transforms/extractions/_acl' ) Source code in solnlib/acl.py @retry ( exceptions = [ binding . HTTPError ]) def get ( self , path : str ) -> dict : \"\"\"Get ACL of /servicesNS/{`owner`}/{`app`}/{`path`}. Arguments: path: Path of ACL relative to /servicesNS/{`owner`}/{`app`} Returns: A dict contains ACL. Raises: ACLException: If `path` is invalid. Examples: >>> aclm = acl.ACLManager(session_key, 'Splunk_TA_test') >>> perms = aclm.get('data/transforms/extractions/_acl') \"\"\" try : content = self . _rest_client . get ( path , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise ACLException ( \"Invalid endpoint: %s .\" , path ) return json . loads ( content )[ \"entry\" ][ 0 ][ \"acl\" ] update ( self , path , owner = None , perms_read = None , perms_write = None ) \u00b6 Update ACL of /servicesNS/{ owner }/{ app }/{ path }. If the ACL is per-entity (ends in /acl), owner can be reassigned. If the acl is endpoint-level (ends in _acl), owner will be ignored. The \u2018sharing\u2019 setting is always retrieved from the current. Parameters: Name Type Description Default path str Path of ACL relative to /servicesNS/{owner}/{app}. MUST end with /acl or /_acl indicating whether the permission is applied at the per-entity level or endpoint level respectively. required owner str (optional) New owner of ACL, default is nobody . None perms_read List (optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.read, default is None. None perms_write List (optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.write, default is None. None Returns: Type Description dict A dict contains ACL after update. Exceptions: Type Description ACLException If path is invalid. Examples: >>> aclm = acl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> perms = aclm . update ( 'data/transforms/extractions/_acl' , perms_read = [ 'admin' ], perms_write = [ 'admin' ]) Source code in solnlib/acl.py @retry ( exceptions = [ binding . HTTPError ]) def update ( self , path : str , owner : str = None , perms_read : List = None , perms_write : List = None , ) -> dict : \"\"\"Update ACL of /servicesNS/{`owner`}/{`app`}/{`path`}. If the ACL is per-entity (ends in /acl), owner can be reassigned. If the acl is endpoint-level (ends in _acl), owner will be ignored. The 'sharing' setting is always retrieved from the current. Arguments: path: Path of ACL relative to /servicesNS/{owner}/{app}. MUST end with /acl or /_acl indicating whether the permission is applied at the per-entity level or endpoint level respectively. owner: (optional) New owner of ACL, default is `nobody`. perms_read: (optional) List of roles (['*'] for all roles). If unspecified we will POST with current (if available) perms.read, default is None. perms_write: (optional) List of roles (['*'] for all roles). If unspecified we will POST with current (if available) perms.write, default is None. Returns: A dict contains ACL after update. Raises: ACLException: If `path` is invalid. Examples: >>> aclm = acl.ACLManager(session_key, 'Splunk_TA_test') >>> perms = aclm.update('data/transforms/extractions/_acl', perms_read=['admin'], perms_write=['admin']) \"\"\" if not path . endswith ( \"/acl\" ) and not path . endswith ( \"/_acl\" ): raise ACLException ( \"Invalid endpoint: %s , must end with /acl or /_acl.\" % path ) curr_acl = self . get ( path ) postargs = {} if perms_read : postargs [ \"perms.read\" ] = \",\" . join ( perms_read ) else : curr_read = curr_acl [ \"perms\" ] . get ( \"read\" , []) if curr_read : postargs [ \"perms.read\" ] = \",\" . join ( curr_read ) if perms_write : postargs [ \"perms.write\" ] = \",\" . join ( perms_write ) else : curr_write = curr_acl [ \"perms\" ] . get ( \"write\" , []) if curr_write : postargs [ \"perms.write\" ] = \",\" . join ( curr_write ) if path . endswith ( \"/acl\" ): # Allow ownership to be reset only at entity level. postargs [ \"owner\" ] = owner or curr_acl [ \"owner\" ] postargs [ \"sharing\" ] = curr_acl [ \"sharing\" ] try : content = self . _rest_client . post ( path , body = binding . _encode ( ** postargs ), output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise ACLException ( \"Invalid endpoint: %s .\" , path ) return json . loads ( content )[ \"entry\" ][ 0 ][ \"acl\" ]","title":"acl.py"},{"location":"acl/#solnlib.acl.__all__","text":"","title":"__all__"},{"location":"acl/#solnlib.acl.ACLException","text":"Exception raised by ACLManager.","title":"ACLException"},{"location":"acl/#solnlib.acl.ACLManager","text":"ACL manager. Examples: >>> import solnlib.acl as sacl >>> saclm = sacl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> saclm . get ( 'data/transforms/extractions' ) >>> saclm . update ( 'data/transforms/extractions/_acl' , perms_read = [ '*' ], perms_write = [ '*' ])","title":"ACLManager"},{"location":"acl/#solnlib.acl.ACLManager.__init__","text":"Initializes ACLManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/acl.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes ACLManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , app , owner = owner , scheme = scheme , host = host , port = port , ** context )","title":"__init__()"},{"location":"acl/#solnlib.acl.ACLManager.get","text":"Get ACL of /servicesNS/{ owner }/{ app }/{ path }. Parameters: Name Type Description Default path str Path of ACL relative to /servicesNS/{ owner }/{ app } required Returns: Type Description dict A dict contains ACL. Exceptions: Type Description ACLException If path is invalid. Examples: >>> aclm = acl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> perms = aclm . get ( 'data/transforms/extractions/_acl' ) Source code in solnlib/acl.py @retry ( exceptions = [ binding . HTTPError ]) def get ( self , path : str ) -> dict : \"\"\"Get ACL of /servicesNS/{`owner`}/{`app`}/{`path`}. Arguments: path: Path of ACL relative to /servicesNS/{`owner`}/{`app`} Returns: A dict contains ACL. Raises: ACLException: If `path` is invalid. Examples: >>> aclm = acl.ACLManager(session_key, 'Splunk_TA_test') >>> perms = aclm.get('data/transforms/extractions/_acl') \"\"\" try : content = self . _rest_client . get ( path , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise ACLException ( \"Invalid endpoint: %s .\" , path ) return json . loads ( content )[ \"entry\" ][ 0 ][ \"acl\" ]","title":"get()"},{"location":"acl/#solnlib.acl.ACLManager.update","text":"Update ACL of /servicesNS/{ owner }/{ app }/{ path }. If the ACL is per-entity (ends in /acl), owner can be reassigned. If the acl is endpoint-level (ends in _acl), owner will be ignored. The \u2018sharing\u2019 setting is always retrieved from the current. Parameters: Name Type Description Default path str Path of ACL relative to /servicesNS/{owner}/{app}. MUST end with /acl or /_acl indicating whether the permission is applied at the per-entity level or endpoint level respectively. required owner str (optional) New owner of ACL, default is nobody . None perms_read List (optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.read, default is None. None perms_write List (optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.write, default is None. None Returns: Type Description dict A dict contains ACL after update. Exceptions: Type Description ACLException If path is invalid. Examples: >>> aclm = acl . ACLManager ( session_key , 'Splunk_TA_test' ) >>> perms = aclm . update ( 'data/transforms/extractions/_acl' , perms_read = [ 'admin' ], perms_write = [ 'admin' ]) Source code in solnlib/acl.py @retry ( exceptions = [ binding . HTTPError ]) def update ( self , path : str , owner : str = None , perms_read : List = None , perms_write : List = None , ) -> dict : \"\"\"Update ACL of /servicesNS/{`owner`}/{`app`}/{`path`}. If the ACL is per-entity (ends in /acl), owner can be reassigned. If the acl is endpoint-level (ends in _acl), owner will be ignored. The 'sharing' setting is always retrieved from the current. Arguments: path: Path of ACL relative to /servicesNS/{owner}/{app}. MUST end with /acl or /_acl indicating whether the permission is applied at the per-entity level or endpoint level respectively. owner: (optional) New owner of ACL, default is `nobody`. perms_read: (optional) List of roles (['*'] for all roles). If unspecified we will POST with current (if available) perms.read, default is None. perms_write: (optional) List of roles (['*'] for all roles). If unspecified we will POST with current (if available) perms.write, default is None. Returns: A dict contains ACL after update. Raises: ACLException: If `path` is invalid. Examples: >>> aclm = acl.ACLManager(session_key, 'Splunk_TA_test') >>> perms = aclm.update('data/transforms/extractions/_acl', perms_read=['admin'], perms_write=['admin']) \"\"\" if not path . endswith ( \"/acl\" ) and not path . endswith ( \"/_acl\" ): raise ACLException ( \"Invalid endpoint: %s , must end with /acl or /_acl.\" % path ) curr_acl = self . get ( path ) postargs = {} if perms_read : postargs [ \"perms.read\" ] = \",\" . join ( perms_read ) else : curr_read = curr_acl [ \"perms\" ] . get ( \"read\" , []) if curr_read : postargs [ \"perms.read\" ] = \",\" . join ( curr_read ) if perms_write : postargs [ \"perms.write\" ] = \",\" . join ( perms_write ) else : curr_write = curr_acl [ \"perms\" ] . get ( \"write\" , []) if curr_write : postargs [ \"perms.write\" ] = \",\" . join ( curr_write ) if path . endswith ( \"/acl\" ): # Allow ownership to be reset only at entity level. postargs [ \"owner\" ] = owner or curr_acl [ \"owner\" ] postargs [ \"sharing\" ] = curr_acl [ \"sharing\" ] try : content = self . _rest_client . post ( path , body = binding . _encode ( ** postargs ), output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise ACLException ( \"Invalid endpoint: %s .\" , path ) return json . loads ( content )[ \"entry\" ][ 0 ][ \"acl\" ]","title":"update()"},{"location":"conf_manager/","text":"This module contains simple interfaces for Splunk config file management, you can update/get/delete stanzas and encrypt/decrypt some fields of stanza automatically. __all__ special \u00b6 ConfFile \u00b6 Configuration file. ENCRYPTED_TOKEN \u00b6 reserved_keys \u00b6 __init__ ( self , name , conf , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , realm = None , ** context ) special \u00b6 Initializes ConfFile. Parameters: Name Type Description Default name str Configuration file name. required conf ConfigurationFile Configuration file object. required session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None realm str (optional) Realm of credential, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/conf_manager.py def __init__ ( self , name : str , conf : client . ConfigurationFile , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , realm : str = None , ** context : dict , ): \"\"\"Initializes ConfFile. Arguments: name: Configuration file name. conf: Configuration file object. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. realm: (optional) Realm of credential, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _name = name self . _conf = conf self . _session_key = session_key self . _app = app self . _owner = owner self . _scheme = scheme self . _host = host self . _port = port self . _context = context self . _cred_manager = None ### 'realm' is set to provided 'realm' argument otherwise as default behaviour it is set to 'APP_NAME'. if realm is None : self . _realm = self . _app else : self . _realm = realm delete ( self , stanza_name ) \u00b6 Delete stanza. Parameters: Name Type Description Default stanza_name str Stanza name to delete. required Exceptions: Type Description ConfStanzaNotExistException If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . delete ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def delete ( self , stanza_name : str ): \"\"\"Delete stanza. Arguments: stanza_name: Stanza name to delete. Raises: ConfStanzaNotExistException: If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.delete('test_stanza') \"\"\" try : self . _cred_mgr . delete_password ( stanza_name ) except CredentialNotExistException : pass try : self . _conf . delete ( stanza_name ) except KeyError as e : logging . error ( \"Delete stanza: %s error: %s .\" , stanza_name , traceback . format_exc () ) raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" ) get ( self , stanza_name , only_current_app = False ) \u00b6 Get stanza from configuration file. Result is like: { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } Parameters: Name Type Description Default stanza_name str Stanza name. required only_current_app bool Only include current app. False Returns: Type Description dict Stanza. Exceptions: Type Description ConfStanzaNotExistException If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . get ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get ( self , stanza_name : str , only_current_app : bool = False ) -> dict : \"\"\"Get stanza from configuration file. Result is like: { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } Arguments: stanza_name: Stanza name. only_current_app: Only include current app. Returns: Stanza. Raises: ConfStanzaNotExistException: If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.get('test_stanza') \"\"\" try : if only_current_app : stanza_mgrs = self . _conf . list ( search = \"eai:acl.app= {} name= {} \" . format ( self . _app , stanza_name . replace ( \"=\" , r \"\\=\" ) ) ) else : stanza_mgrs = self . _conf . list ( name = stanza_name ) except binding . HTTPError as e : if e . status != 404 : raise raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" ) if len ( stanza_mgrs ) == 0 : raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" ) stanza = self . _decrypt_stanza ( stanza_mgrs [ 0 ] . name , stanza_mgrs [ 0 ] . content ) stanza [ \"eai:access\" ] = stanza_mgrs [ 0 ] . access stanza [ \"eai:appName\" ] = stanza_mgrs [ 0 ] . access . app return stanza get_all ( self , only_current_app = False ) \u00b6 Get all stanzas from configuration file. Result is like: { 'test': { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } } Parameters: Name Type Description Default only_current_app bool Only include current app. False Returns: Type Description dict Dict of stanzas. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . get_all () Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get_all ( self , only_current_app : bool = False ) -> dict : \"\"\"Get all stanzas from configuration file. Result is like: { 'test': { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } } Arguments: only_current_app: Only include current app. Returns: Dict of stanzas. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.get_all() \"\"\" if only_current_app : stanza_mgrs = self . _conf . list ( search = f \"eai:acl.app= { self . _app } \" ) else : stanza_mgrs = self . _conf . list () res = {} for stanza_mgr in stanza_mgrs : name = stanza_mgr . name key_values = self . _decrypt_stanza ( name , stanza_mgr . content ) key_values [ \"eai:access\" ] = stanza_mgr . access key_values [ \"eai:appName\" ] = stanza_mgr . access . app res [ name ] = key_values return res reload ( self ) \u00b6 Reload configuration file. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . reload () Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def reload ( self ): \"\"\"Reload configuration file. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.reload() \"\"\" self . _conf . get ( \"_reload\" ) stanza_exist ( self , stanza_name ) \u00b6 Check whether stanza exists. Parameters: Name Type Description Default stanza_name str Stanza name. required Returns: Type Description bool True if stanza exists else False. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . stanza_exist ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def stanza_exist ( self , stanza_name : str ) -> bool : \"\"\"Check whether stanza exists. Arguments: stanza_name: Stanza name. Returns: True if stanza exists else False. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.stanza_exist('test_stanza') \"\"\" try : self . _conf . list ( name = stanza_name )[ 0 ] except binding . HTTPError as e : if e . status != 404 : raise return False return True update ( self , stanza_name , stanza , encrypt_keys = None ) \u00b6 Update stanza. It will try to encrypt the credential automatically fist if encrypt_keys are not None else keep stanza untouched. Parameters: Name Type Description Default stanza_name str Stanza name. required stanza dict Stanza to update. required encrypt_keys List[str] Field names to encrypt. None Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . update ( 'test_stanza' , { 'k1' : 1 , 'k2' : 2 }, [ 'k1' ]) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def update ( self , stanza_name : str , stanza : dict , encrypt_keys : List [ str ] = None ): \"\"\"Update stanza. It will try to encrypt the credential automatically fist if encrypt_keys are not None else keep stanza untouched. Arguments: stanza_name: Stanza name. stanza: Stanza to update. encrypt_keys: Field names to encrypt. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.update('test_stanza', {'k1': 1, 'k2': 2}, ['k1']) \"\"\" stanza = self . _filter_stanza ( stanza ) encrypted_stanza = self . _encrypt_stanza ( stanza_name , stanza , encrypt_keys ) try : stanza_mgr = self . _conf . list ( name = stanza_name )[ 0 ] except binding . HTTPError as e : if e . status != 404 : raise stanza_mgr = self . _conf . create ( stanza_name ) stanza_mgr . submit ( encrypted_stanza ) ConfManager \u00b6 Configuration file manager. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) Examples: If stanza in passwords.conf is formatted as below: credential:__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME:STANZA_NAME``splunk_cred_sep``1: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' , realm = '__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME' ) __init__ ( self , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , realm = None , ** context ) special \u00b6 Initializes ConfManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None realm str (optional) Realm of credential, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/conf_manager.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , realm : str = None , ** context : dict , ): \"\"\"Initializes ConfManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. realm: (optional) Realm of credential, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _session_key = session_key self . _app = app self . _owner = owner self . _scheme = scheme self . _host = host self . _port = port self . _context = context self . _rest_client = rest_client . SplunkRestClient ( self . _session_key , self . _app , owner = self . _owner , scheme = self . _scheme , host = self . _host , port = self . _port , ** self . _context , ) self . _confs = None self . _realm = realm create_conf ( self , name ) \u00b6 Create conf file. Parameters: Name Type Description Default name str Conf file name. required Returns: Type Description ConfFile Conf file object. Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def create_conf ( self , name : str ) -> ConfFile : \"\"\"Create conf file. Arguments: name: Conf file name. Returns: Conf file object. \"\"\" if self . _confs is None : self . _confs = self . _rest_client . confs conf = self . _confs . create ( name ) return ConfFile ( name , conf , self . _session_key , self . _app , self . _owner , self . _scheme , self . _host , self . _port , self . _realm , ** self . _context , ) get_conf ( self , name , refresh = False ) \u00b6 Get conf file. Parameters: Name Type Description Default name str Conf file name. required refresh bool (optional) Flag to refresh conf file list, default is False. False Returns: Type Description ConfFile Conf file object. Exceptions: Type Description ConfManagerException If conf_file does not exist. Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get_conf ( self , name : str , refresh : bool = False ) -> ConfFile : \"\"\"Get conf file. Arguments: name: Conf file name. refresh: (optional) Flag to refresh conf file list, default is False. Returns: Conf file object. Raises: ConfManagerException: If `conf_file` does not exist. \"\"\" if self . _confs is None or refresh : # Fix bug that can't pass `-` as app name. curr_app = self . _rest_client . namespace . app self . _rest_client . namespace . app = \"dummy\" self . _confs = self . _rest_client . confs self . _rest_client . namespace . app = curr_app try : conf = self . _confs [ name ] except KeyError : raise ConfManagerException ( \"Config file: %s does not exist.\" % name ) return ConfFile ( name , conf , self . _session_key , self . _app , self . _owner , self . _scheme , self . _host , self . _port , self . _realm , ** self . _context , ) ConfManagerException ( Exception ) \u00b6 Exception raised by ConfManager class. ConfStanzaNotExistException ( Exception ) \u00b6 Exception raised by ConfFile class.","title":"conf_manager.py"},{"location":"conf_manager/#solnlib.conf_manager.__all__","text":"","title":"__all__"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile","text":"Configuration file.","title":"ConfFile"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.ENCRYPTED_TOKEN","text":"","title":"ENCRYPTED_TOKEN"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.reserved_keys","text":"","title":"reserved_keys"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.__init__","text":"Initializes ConfFile. Parameters: Name Type Description Default name str Configuration file name. required conf ConfigurationFile Configuration file object. required session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None realm str (optional) Realm of credential, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/conf_manager.py def __init__ ( self , name : str , conf : client . ConfigurationFile , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , realm : str = None , ** context : dict , ): \"\"\"Initializes ConfFile. Arguments: name: Configuration file name. conf: Configuration file object. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. realm: (optional) Realm of credential, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _name = name self . _conf = conf self . _session_key = session_key self . _app = app self . _owner = owner self . _scheme = scheme self . _host = host self . _port = port self . _context = context self . _cred_manager = None ### 'realm' is set to provided 'realm' argument otherwise as default behaviour it is set to 'APP_NAME'. if realm is None : self . _realm = self . _app else : self . _realm = realm","title":"__init__()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.delete","text":"Delete stanza. Parameters: Name Type Description Default stanza_name str Stanza name to delete. required Exceptions: Type Description ConfStanzaNotExistException If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . delete ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def delete ( self , stanza_name : str ): \"\"\"Delete stanza. Arguments: stanza_name: Stanza name to delete. Raises: ConfStanzaNotExistException: If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.delete('test_stanza') \"\"\" try : self . _cred_mgr . delete_password ( stanza_name ) except CredentialNotExistException : pass try : self . _conf . delete ( stanza_name ) except KeyError as e : logging . error ( \"Delete stanza: %s error: %s .\" , stanza_name , traceback . format_exc () ) raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" )","title":"delete()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.get","text":"Get stanza from configuration file. Result is like: { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } Parameters: Name Type Description Default stanza_name str Stanza name. required only_current_app bool Only include current app. False Returns: Type Description dict Stanza. Exceptions: Type Description ConfStanzaNotExistException If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . get ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get ( self , stanza_name : str , only_current_app : bool = False ) -> dict : \"\"\"Get stanza from configuration file. Result is like: { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } Arguments: stanza_name: Stanza name. only_current_app: Only include current app. Returns: Stanza. Raises: ConfStanzaNotExistException: If stanza does not exist. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.get('test_stanza') \"\"\" try : if only_current_app : stanza_mgrs = self . _conf . list ( search = \"eai:acl.app= {} name= {} \" . format ( self . _app , stanza_name . replace ( \"=\" , r \"\\=\" ) ) ) else : stanza_mgrs = self . _conf . list ( name = stanza_name ) except binding . HTTPError as e : if e . status != 404 : raise raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" ) if len ( stanza_mgrs ) == 0 : raise ConfStanzaNotExistException ( f \"Stanza: { stanza_name } does not exist in { self . _name } .conf\" ) stanza = self . _decrypt_stanza ( stanza_mgrs [ 0 ] . name , stanza_mgrs [ 0 ] . content ) stanza [ \"eai:access\" ] = stanza_mgrs [ 0 ] . access stanza [ \"eai:appName\" ] = stanza_mgrs [ 0 ] . access . app return stanza","title":"get()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.get_all","text":"Get all stanzas from configuration file. Result is like: { 'test': { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } } Parameters: Name Type Description Default only_current_app bool Only include current app. False Returns: Type Description dict Dict of stanzas. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . get_all () Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get_all ( self , only_current_app : bool = False ) -> dict : \"\"\"Get all stanzas from configuration file. Result is like: { 'test': { 'disabled': '0', 'eai:appName': 'solnlib_demo', 'eai:userName': 'nobody', 'k1': '1', 'k2': '2' } } Arguments: only_current_app: Only include current app. Returns: Dict of stanzas. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.get_all() \"\"\" if only_current_app : stanza_mgrs = self . _conf . list ( search = f \"eai:acl.app= { self . _app } \" ) else : stanza_mgrs = self . _conf . list () res = {} for stanza_mgr in stanza_mgrs : name = stanza_mgr . name key_values = self . _decrypt_stanza ( name , stanza_mgr . content ) key_values [ \"eai:access\" ] = stanza_mgr . access key_values [ \"eai:appName\" ] = stanza_mgr . access . app res [ name ] = key_values return res","title":"get_all()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.reload","text":"Reload configuration file. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . reload () Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def reload ( self ): \"\"\"Reload configuration file. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.reload() \"\"\" self . _conf . get ( \"_reload\" )","title":"reload()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.stanza_exist","text":"Check whether stanza exists. Parameters: Name Type Description Default stanza_name str Stanza name. required Returns: Type Description bool True if stanza exists else False. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . stanza_exist ( 'test_stanza' ) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def stanza_exist ( self , stanza_name : str ) -> bool : \"\"\"Check whether stanza exists. Arguments: stanza_name: Stanza name. Returns: True if stanza exists else False. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.stanza_exist('test_stanza') \"\"\" try : self . _conf . list ( name = stanza_name )[ 0 ] except binding . HTTPError as e : if e . status != 404 : raise return False return True","title":"stanza_exist()"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.update","text":"Update stanza. It will try to encrypt the credential automatically fist if encrypt_keys are not None else keep stanza untouched. Parameters: Name Type Description Default stanza_name str Stanza name. required stanza dict Stanza to update. required encrypt_keys List[str] Field names to encrypt. None Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) >>> conf = cfm . get_conf ( 'test' ) >>> conf . update ( 'test_stanza' , { 'k1' : 1 , 'k2' : 2 }, [ 'k1' ]) Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def update ( self , stanza_name : str , stanza : dict , encrypt_keys : List [ str ] = None ): \"\"\"Update stanza. It will try to encrypt the credential automatically fist if encrypt_keys are not None else keep stanza untouched. Arguments: stanza_name: Stanza name. stanza: Stanza to update. encrypt_keys: Field names to encrypt. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager.ConfManager(session_key, 'Splunk_TA_test') >>> conf = cfm.get_conf('test') >>> conf.update('test_stanza', {'k1': 1, 'k2': 2}, ['k1']) \"\"\" stanza = self . _filter_stanza ( stanza ) encrypted_stanza = self . _encrypt_stanza ( stanza_name , stanza , encrypt_keys ) try : stanza_mgr = self . _conf . list ( name = stanza_name )[ 0 ] except binding . HTTPError as e : if e . status != 404 : raise stanza_mgr = self . _conf . create ( stanza_name ) stanza_mgr . submit ( encrypted_stanza )","title":"update()"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager","text":"Configuration file manager. Examples: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' ) Examples: If stanza in passwords.conf is formatted as below: credential:__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME:STANZA_NAME``splunk_cred_sep``1: >>> from solnlib import conf_manager >>> cfm = conf_manager . ConfManager ( session_key , 'Splunk_TA_test' , realm = '__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME' )","title":"ConfManager"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.__init__","text":"Initializes ConfManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None realm str (optional) Realm of credential, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/conf_manager.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , realm : str = None , ** context : dict , ): \"\"\"Initializes ConfManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. realm: (optional) Realm of credential, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _session_key = session_key self . _app = app self . _owner = owner self . _scheme = scheme self . _host = host self . _port = port self . _context = context self . _rest_client = rest_client . SplunkRestClient ( self . _session_key , self . _app , owner = self . _owner , scheme = self . _scheme , host = self . _host , port = self . _port , ** self . _context , ) self . _confs = None self . _realm = realm","title":"__init__()"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.create_conf","text":"Create conf file. Parameters: Name Type Description Default name str Conf file name. required Returns: Type Description ConfFile Conf file object. Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def create_conf ( self , name : str ) -> ConfFile : \"\"\"Create conf file. Arguments: name: Conf file name. Returns: Conf file object. \"\"\" if self . _confs is None : self . _confs = self . _rest_client . confs conf = self . _confs . create ( name ) return ConfFile ( name , conf , self . _session_key , self . _app , self . _owner , self . _scheme , self . _host , self . _port , self . _realm , ** self . _context , )","title":"create_conf()"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.get_conf","text":"Get conf file. Parameters: Name Type Description Default name str Conf file name. required refresh bool (optional) Flag to refresh conf file list, default is False. False Returns: Type Description ConfFile Conf file object. Exceptions: Type Description ConfManagerException If conf_file does not exist. Source code in solnlib/conf_manager.py @retry ( exceptions = [ binding . HTTPError ]) def get_conf ( self , name : str , refresh : bool = False ) -> ConfFile : \"\"\"Get conf file. Arguments: name: Conf file name. refresh: (optional) Flag to refresh conf file list, default is False. Returns: Conf file object. Raises: ConfManagerException: If `conf_file` does not exist. \"\"\" if self . _confs is None or refresh : # Fix bug that can't pass `-` as app name. curr_app = self . _rest_client . namespace . app self . _rest_client . namespace . app = \"dummy\" self . _confs = self . _rest_client . confs self . _rest_client . namespace . app = curr_app try : conf = self . _confs [ name ] except KeyError : raise ConfManagerException ( \"Config file: %s does not exist.\" % name ) return ConfFile ( name , conf , self . _session_key , self . _app , self . _owner , self . _scheme , self . _host , self . _port , self . _realm , ** self . _context , )","title":"get_conf()"},{"location":"conf_manager/#solnlib.conf_manager.ConfManagerException","text":"Exception raised by ConfManager class.","title":"ConfManagerException"},{"location":"conf_manager/#solnlib.conf_manager.ConfStanzaNotExistException","text":"Exception raised by ConfFile class.","title":"ConfStanzaNotExistException"},{"location":"credentials/","text":"This module contains Splunk credential related interfaces. __all__ special \u00b6 CredentialException ( Exception ) \u00b6 General exception regarding credentials. CredentialManager \u00b6 Credential manager. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) END_MARK \u00b6 SEP \u00b6 SPLUNK_CRED_LEN_LIMIT \u00b6 __init__ ( self , session_key , app , owner = 'nobody' , realm = None , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes CredentialsManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' realm str (optional) Realm of credential, default is None. None scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/credentials.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , realm : str = None , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes CredentialsManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. realm: (optional) Realm of credential, default is None. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _realm = realm self . service = rest_client . SplunkRestClient ( session_key , app , owner = owner , scheme = scheme , host = host , port = port , ** context , ) self . _storage_passwords = self . service . storage_passwords delete_password ( self , user ) \u00b6 Delete password. Parameters: Name Type Description Default user str User name. required Exceptions: Type Description CredentialNotExistException If password of realm:user doesn\u2019t exist. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . delete_password ( 'testuser1' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def delete_password ( self , user : str ): \"\"\"Delete password. Arguments: user: User name. Raises: CredentialNotExistException: If password of realm:user doesn't exist. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.delete_password('testuser1') \"\"\" all_passwords = self . _get_all_passwords_in_realm () deleted = False ent_pattern = re . compile ( r \"( {}{} \\d+)\" . format ( user . replace ( \" \\\\ \" , \" \\\\\\\\ \" ), self . SEP ) ) for password in list ( all_passwords ): match = ( user == password . username ) or ent_pattern . match ( password . username ) if match and password . realm == self . _realm : password . delete () deleted = True if not deleted : raise CredentialNotExistException ( \"Failed to delete password of realm= {} , user= {} \" . format ( self . _realm , user ) ) get_password ( self , user ) \u00b6 Get password. Parameters: Name Type Description Default user str User name. required Returns: Type Description str Clear user password. Exceptions: Type Description CredentialNotExistException If password for \u2018realm:user\u2019 doesn\u2019t exist. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . get_password ( 'testuser2' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def get_password ( self , user : str ) -> str : \"\"\"Get password. Arguments: user: User name. Returns: Clear user password. Raises: CredentialNotExistException: If password for 'realm:user' doesn't exist. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.get_password('testuser2') \"\"\" all_passwords = self . _get_all_passwords () for password in all_passwords : if password [ \"username\" ] == user and password [ \"realm\" ] == self . _realm : return password [ \"clear_password\" ] raise CredentialNotExistException ( f \"Failed to get password of realm= { self . _realm } , user= { user } .\" ) set_password ( self , user , password ) \u00b6 Set password. Parameters: Name Type Description Default user str User name. required password str User password. required Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . set_password ( 'testuser1' , 'password1' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def set_password ( self , user : str , password : str ): \"\"\"Set password. Arguments: user: User name. password: User password. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.set_password('testuser1', 'password1') \"\"\" length = 0 index = 1 while length < len ( password ): curr_str = password [ length : length + self . SPLUNK_CRED_LEN_LIMIT ] partial_user = self . SEP . join ([ user , str ( index )]) self . _update_password ( partial_user , curr_str ) length += self . SPLUNK_CRED_LEN_LIMIT index += 1 # Append another stanza to mark the end of the password partial_user = self . SEP . join ([ user , str ( index )]) self . _update_password ( partial_user , self . END_MARK ) CredentialNotExistException ( Exception ) \u00b6 Exception is raised when credentials do not exist. get_session_key ( username , password , scheme = None , host = None , port = None , ** context ) \u00b6 Get splunkd access token. Parameters: Name Type Description Default username str The Splunk account username, which is used to authenticate the Splunk instance. required password str The Splunk account password. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description str Splunk session key. Exceptions: Type Description CredentialException If username/password are invalid. ValueError if scheme, host or port are invalid. Examples: >>> credentials . get_session_key ( 'user' , 'password' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def get_session_key ( username : str , password : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> str : \"\"\"Get splunkd access token. Arguments: username: The Splunk account username, which is used to authenticate the Splunk instance. password: The Splunk account password. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: Splunk session key. Raises: CredentialException: If username/password are invalid. ValueError: if scheme, host or port are invalid. Examples: >>> credentials.get_session_key('user', 'password') \"\"\" validate_scheme_host_port ( scheme , host , port ) if any ([ scheme is None , host is None , port is None ]): scheme , host , port = get_splunkd_access_info () uri = \" {scheme} :// {host} : {port} / {endpoint} \" . format ( scheme = scheme , host = host , port = port , endpoint = \"services/auth/login\" ) _rest_client = rest_client . SplunkRestClient ( None , \"-\" , \"nobody\" , scheme , host , port , ** context ) try : response = _rest_client . http . post ( uri , username = username , password = password , output_mode = \"json\" ) except binding . HTTPError as e : if e . status != 401 : raise raise CredentialException ( \"Invalid username/password.\" ) return json . loads ( response . body . read ())[ \"sessionKey\" ]","title":"credentials.py"},{"location":"credentials/#solnlib.credentials.__all__","text":"","title":"__all__"},{"location":"credentials/#solnlib.credentials.CredentialException","text":"General exception regarding credentials.","title":"CredentialException"},{"location":"credentials/#solnlib.credentials.CredentialManager","text":"Credential manager. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' )","title":"CredentialManager"},{"location":"credentials/#solnlib.credentials.CredentialManager.END_MARK","text":"","title":"END_MARK"},{"location":"credentials/#solnlib.credentials.CredentialManager.SEP","text":"","title":"SEP"},{"location":"credentials/#solnlib.credentials.CredentialManager.SPLUNK_CRED_LEN_LIMIT","text":"","title":"SPLUNK_CRED_LEN_LIMIT"},{"location":"credentials/#solnlib.credentials.CredentialManager.__init__","text":"Initializes CredentialsManager. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' realm str (optional) Realm of credential, default is None. None scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/credentials.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , realm : str = None , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes CredentialsManager. Arguments: session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. realm: (optional) Realm of credential, default is None. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _realm = realm self . service = rest_client . SplunkRestClient ( session_key , app , owner = owner , scheme = scheme , host = host , port = port , ** context , ) self . _storage_passwords = self . service . storage_passwords","title":"__init__()"},{"location":"credentials/#solnlib.credentials.CredentialManager.delete_password","text":"Delete password. Parameters: Name Type Description Default user str User name. required Exceptions: Type Description CredentialNotExistException If password of realm:user doesn\u2019t exist. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . delete_password ( 'testuser1' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def delete_password ( self , user : str ): \"\"\"Delete password. Arguments: user: User name. Raises: CredentialNotExistException: If password of realm:user doesn't exist. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.delete_password('testuser1') \"\"\" all_passwords = self . _get_all_passwords_in_realm () deleted = False ent_pattern = re . compile ( r \"( {}{} \\d+)\" . format ( user . replace ( \" \\\\ \" , \" \\\\\\\\ \" ), self . SEP ) ) for password in list ( all_passwords ): match = ( user == password . username ) or ent_pattern . match ( password . username ) if match and password . realm == self . _realm : password . delete () deleted = True if not deleted : raise CredentialNotExistException ( \"Failed to delete password of realm= {} , user= {} \" . format ( self . _realm , user ) )","title":"delete_password()"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_password","text":"Get password. Parameters: Name Type Description Default user str User name. required Returns: Type Description str Clear user password. Exceptions: Type Description CredentialNotExistException If password for \u2018realm:user\u2019 doesn\u2019t exist. Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . get_password ( 'testuser2' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def get_password ( self , user : str ) -> str : \"\"\"Get password. Arguments: user: User name. Returns: Clear user password. Raises: CredentialNotExistException: If password for 'realm:user' doesn't exist. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.get_password('testuser2') \"\"\" all_passwords = self . _get_all_passwords () for password in all_passwords : if password [ \"username\" ] == user and password [ \"realm\" ] == self . _realm : return password [ \"clear_password\" ] raise CredentialNotExistException ( f \"Failed to get password of realm= { self . _realm } , user= { user } .\" )","title":"get_password()"},{"location":"credentials/#solnlib.credentials.CredentialManager.set_password","text":"Set password. Parameters: Name Type Description Default user str User name. required password str User password. required Examples: >>> from solnlib import credentials >>> cm = credentials . CredentialManager ( session_key , 'Splunk_TA_test' , realm = 'realm_test' ) >>> cm . set_password ( 'testuser1' , 'password1' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def set_password ( self , user : str , password : str ): \"\"\"Set password. Arguments: user: User name. password: User password. Examples: >>> from solnlib import credentials >>> cm = credentials.CredentialManager(session_key, 'Splunk_TA_test', realm='realm_test') >>> cm.set_password('testuser1', 'password1') \"\"\" length = 0 index = 1 while length < len ( password ): curr_str = password [ length : length + self . SPLUNK_CRED_LEN_LIMIT ] partial_user = self . SEP . join ([ user , str ( index )]) self . _update_password ( partial_user , curr_str ) length += self . SPLUNK_CRED_LEN_LIMIT index += 1 # Append another stanza to mark the end of the password partial_user = self . SEP . join ([ user , str ( index )]) self . _update_password ( partial_user , self . END_MARK )","title":"set_password()"},{"location":"credentials/#solnlib.credentials.CredentialNotExistException","text":"Exception is raised when credentials do not exist.","title":"CredentialNotExistException"},{"location":"credentials/#solnlib.credentials.get_session_key","text":"Get splunkd access token. Parameters: Name Type Description Default username str The Splunk account username, which is used to authenticate the Splunk instance. required password str The Splunk account password. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description str Splunk session key. Exceptions: Type Description CredentialException If username/password are invalid. ValueError if scheme, host or port are invalid. Examples: >>> credentials . get_session_key ( 'user' , 'password' ) Source code in solnlib/credentials.py @retry ( exceptions = [ binding . HTTPError ]) def get_session_key ( username : str , password : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> str : \"\"\"Get splunkd access token. Arguments: username: The Splunk account username, which is used to authenticate the Splunk instance. password: The Splunk account password. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: Splunk session key. Raises: CredentialException: If username/password are invalid. ValueError: if scheme, host or port are invalid. Examples: >>> credentials.get_session_key('user', 'password') \"\"\" validate_scheme_host_port ( scheme , host , port ) if any ([ scheme is None , host is None , port is None ]): scheme , host , port = get_splunkd_access_info () uri = \" {scheme} :// {host} : {port} / {endpoint} \" . format ( scheme = scheme , host = host , port = port , endpoint = \"services/auth/login\" ) _rest_client = rest_client . SplunkRestClient ( None , \"-\" , \"nobody\" , scheme , host , port , ** context ) try : response = _rest_client . http . post ( uri , username = username , password = password , output_mode = \"json\" ) except binding . HTTPError as e : if e . status != 401 : raise raise CredentialException ( \"Invalid username/password.\" ) return json . loads ( response . body . read ())[ \"sessionKey\" ]","title":"get_session_key()"},{"location":"file_monitor/","text":"This module contains file monitoring class that can be used to check files change periodically and call callback function to handle properly when detecting files change. __all__ special \u00b6 FileChangesChecker \u00b6 Files change checker. __init__ ( self , callback , files ) special \u00b6 Initializes FileChangesChecker. Parameters: Name Type Description Default callback Callable Callback function for files change. required files List Files to be monitored with full path. required Source code in solnlib/file_monitor.py def __init__ ( self , callback : Callable , files : List ): \"\"\"Initializes FileChangesChecker. Arguments: callback: Callback function for files change. files: Files to be monitored with full path. \"\"\" self . _callback = callback self . _files = files self . file_mtimes = { file_name : None for file_name in self . _files } for k in self . file_mtimes : try : self . file_mtimes [ k ] = op . getmtime ( k ) except OSError : logging . debug ( \"Getmtime for %s , failed: %s \" , k , traceback . format_exc ()) check_changes ( self ) \u00b6 Check files change. If some files are changed and callback function is not None, call callback function to handle files change. Returns: Type Description bool True if files changed else False Source code in solnlib/file_monitor.py def check_changes ( self ) -> bool : \"\"\"Check files change. If some files are changed and callback function is not None, call callback function to handle files change. Returns: True if files changed else False \"\"\" logging . debug ( \"Checking files= %s \" , self . _files ) file_mtimes = self . file_mtimes changed_files = [] for f , last_mtime in list ( file_mtimes . items ()): try : current_mtime = op . getmtime ( f ) if current_mtime != last_mtime : file_mtimes [ f ] = current_mtime changed_files . append ( f ) logging . info ( \"Detect %s has changed\" , f ) except OSError : pass if changed_files : if self . _callback : self . _callback ( changed_files ) return True return False FileMonitor \u00b6 Files change monitor. Monitor files change in a separated thread and call callback when there is files change. Examples: >>> import solnlib.file_monitor as fm >>> fm = fm . FileMonitor ( fm_callback , files_list , 5 ) >>> fm . start () __init__ ( self , callback , files , interval = 1 ) special \u00b6 Initializes FileMonitor. Parameters: Name Type Description Default callback Callable Callback for handling files change. required files List Files to monitor. required interval int Interval to check files change. 1 Source code in solnlib/file_monitor.py def __init__ ( self , callback : Callable , files : List , interval : int = 1 ): \"\"\"Initializes FileMonitor. Arguments: callback: Callback for handling files change. files: Files to monitor. interval: Interval to check files change. \"\"\" self . _checker = FileChangesChecker ( callback , files ) self . _thr = threading . Thread ( target = self . _do_monitor ) self . _thr . daemon = True self . _interval = interval self . _started = False start ( self ) \u00b6 Start file monitor. Start a background thread to monitor files change. Source code in solnlib/file_monitor.py def start ( self ): \"\"\"Start file monitor. Start a background thread to monitor files change. \"\"\" if self . _started : return self . _started = True self . _thr . start () stop ( self ) \u00b6 Stop file monitor. Stop the background thread to monitor files change. Source code in solnlib/file_monitor.py def stop ( self ): \"\"\"Stop file monitor. Stop the background thread to monitor files change. \"\"\" self . _started = False","title":"file_monitor.py"},{"location":"file_monitor/#solnlib.file_monitor.__all__","text":"","title":"__all__"},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker","text":"Files change checker.","title":"FileChangesChecker"},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker.__init__","text":"Initializes FileChangesChecker. Parameters: Name Type Description Default callback Callable Callback function for files change. required files List Files to be monitored with full path. required Source code in solnlib/file_monitor.py def __init__ ( self , callback : Callable , files : List ): \"\"\"Initializes FileChangesChecker. Arguments: callback: Callback function for files change. files: Files to be monitored with full path. \"\"\" self . _callback = callback self . _files = files self . file_mtimes = { file_name : None for file_name in self . _files } for k in self . file_mtimes : try : self . file_mtimes [ k ] = op . getmtime ( k ) except OSError : logging . debug ( \"Getmtime for %s , failed: %s \" , k , traceback . format_exc ())","title":"__init__()"},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker.check_changes","text":"Check files change. If some files are changed and callback function is not None, call callback function to handle files change. Returns: Type Description bool True if files changed else False Source code in solnlib/file_monitor.py def check_changes ( self ) -> bool : \"\"\"Check files change. If some files are changed and callback function is not None, call callback function to handle files change. Returns: True if files changed else False \"\"\" logging . debug ( \"Checking files= %s \" , self . _files ) file_mtimes = self . file_mtimes changed_files = [] for f , last_mtime in list ( file_mtimes . items ()): try : current_mtime = op . getmtime ( f ) if current_mtime != last_mtime : file_mtimes [ f ] = current_mtime changed_files . append ( f ) logging . info ( \"Detect %s has changed\" , f ) except OSError : pass if changed_files : if self . _callback : self . _callback ( changed_files ) return True return False","title":"check_changes()"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor","text":"Files change monitor. Monitor files change in a separated thread and call callback when there is files change. Examples: >>> import solnlib.file_monitor as fm >>> fm = fm . FileMonitor ( fm_callback , files_list , 5 ) >>> fm . start ()","title":"FileMonitor"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.__init__","text":"Initializes FileMonitor. Parameters: Name Type Description Default callback Callable Callback for handling files change. required files List Files to monitor. required interval int Interval to check files change. 1 Source code in solnlib/file_monitor.py def __init__ ( self , callback : Callable , files : List , interval : int = 1 ): \"\"\"Initializes FileMonitor. Arguments: callback: Callback for handling files change. files: Files to monitor. interval: Interval to check files change. \"\"\" self . _checker = FileChangesChecker ( callback , files ) self . _thr = threading . Thread ( target = self . _do_monitor ) self . _thr . daemon = True self . _interval = interval self . _started = False","title":"__init__()"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.start","text":"Start file monitor. Start a background thread to monitor files change. Source code in solnlib/file_monitor.py def start ( self ): \"\"\"Start file monitor. Start a background thread to monitor files change. \"\"\" if self . _started : return self . _started = True self . _thr . start ()","title":"start()"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.stop","text":"Stop file monitor. Stop the background thread to monitor files change. Source code in solnlib/file_monitor.py def stop ( self ): \"\"\"Stop file monitor. Stop the background thread to monitor files change. \"\"\" self . _started = False","title":"stop()"},{"location":"hec_config/","text":"__all__ special \u00b6 HECConfig \u00b6 HTTP Event Collector configuration. input_type \u00b6 __init__ ( self , session_key , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes HECConfig. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/hec_config.py def __init__ ( self , session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes HECConfig. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"splunk_httpinput\" , scheme = scheme , host = host , port = port , ** context ) create_input ( self , name , stanza ) \u00b6 Create http data input. Parameters: Name Type Description Default name str HTTP data input name. required stanza dict Data input stanza content. required Returns: Type Description dict Created input. Examples: >>> from solnlib.hec_config import HECConfig >>> hec = HECConfig ( session_key ) >>> hec . create_input ( 'my_hec_data_input' , { 'index' : 'main' , 'sourcetype' : 'hec' }) Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def create_input ( self , name : str , stanza : dict ) -> dict : \"\"\"Create http data input. Arguments: name: HTTP data input name. stanza: Data input stanza content. Returns: Created input. Examples: >>> from solnlib.hec_config import HECConfig >>> hec = HECConfig(session_key) >>> hec.create_input('my_hec_data_input', {'index': 'main', 'sourcetype': 'hec'}) \"\"\" res = self . _rest_client . inputs . create ( name , self . input_type , ** stanza ) return res . content delete_input ( self , name ) \u00b6 Delete http data input. Parameters: Name Type Description Default name str HTTP data input name. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def delete_input ( self , name : str ): \"\"\"Delete http data input. Arguments: name: HTTP data input name. \"\"\" try : self . _rest_client . inputs . delete ( name , self . input_type ) except KeyError : pass get_input ( self , name ) \u00b6 Get http data input. Parameters: Name Type Description Default name str HTTP event collector data input name. required Returns: Type Description dict HTTP event collector data input config dict. Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_input ( self , name : str ) -> dict : \"\"\"Get http data input. Arguments: name: HTTP event collector data input name. Returns: HTTP event collector data input config dict. \"\"\" res = self . _do_get_input ( name ) if res : return res . content else : return None get_limits ( self ) \u00b6 Get HTTP input limits. Returns: Type Description dict HTTP input limits. Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_limits ( self ) -> dict : \"\"\"Get HTTP input limits. Returns: HTTP input limits. \"\"\" return self . _rest_client . confs [ \"limits\" ][ \"http_input\" ] . content get_settings ( self ) \u00b6 Get http data input global settings. Returns: Type Description HTTP global settings, for example { \u2018enableSSL\u2019: 1, \u2018disabled\u2019: 0, \u2018useDeploymentServer\u2019: 0, \u2018port\u2019: 8088 } Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_settings ( self ) -> dict : \"\"\"Get http data input global settings. Returns: HTTP global settings, for example: { 'enableSSL': 1, 'disabled': 0, 'useDeploymentServer': 0, 'port': 8088 } \"\"\" return self . _do_get_input ( self . input_type ) . content set_limits ( self , limits ) \u00b6 Set HTTP input limits. Parameters: Name Type Description Default limits dict HTTP input limits. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def set_limits ( self , limits : dict ): \"\"\"Set HTTP input limits. Arguments: limits: HTTP input limits. \"\"\" res = self . _rest_client . confs [ \"limits\" ][ \"http_input\" ] res . submit ( limits ) update_input ( self , name , stanza ) \u00b6 Update http data input. It will create if the data input doesn\u2019t exist. Parameters: Name Type Description Default name str HTTP data input name. required stanza dict Data input stanza. required Examples: >>> from solnlib import HEConfig >>> hec = HECConfig ( session_key ) >>> hec . update_input ( 'my_hec_data_input' , { 'index' : 'main' , 'sourcetype' : 'hec2' }) Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def update_input ( self , name : str , stanza : dict ): \"\"\"Update http data input. It will create if the data input doesn't exist. Arguments: name: HTTP data input name. stanza: Data input stanza. Examples: >>> from solnlib import HEConfig >>> hec = HECConfig(session_key) >>> hec.update_input('my_hec_data_input', {'index': 'main', 'sourcetype': 'hec2'}) \"\"\" res = self . _do_get_input ( name ) if res is None : return self . create_input ( name , stanza ) res . update ( ** stanza ) update_settings ( self , settings ) \u00b6 Update http data input global settings. Parameters: Name Type Description Default settings dict HTTP global settings. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def update_settings ( self , settings : dict ): \"\"\"Update http data input global settings. Arguments: settings: HTTP global settings. \"\"\" res = self . _do_get_input ( self . input_type ) res . update ( ** settings )","title":"hec_config.py"},{"location":"hec_config/#solnlib.hec_config.__all__","text":"","title":"__all__"},{"location":"hec_config/#solnlib.hec_config.HECConfig","text":"HTTP Event Collector configuration.","title":"HECConfig"},{"location":"hec_config/#solnlib.hec_config.HECConfig.input_type","text":"","title":"input_type"},{"location":"hec_config/#solnlib.hec_config.HECConfig.__init__","text":"Initializes HECConfig. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/hec_config.py def __init__ ( self , session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes HECConfig. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"splunk_httpinput\" , scheme = scheme , host = host , port = port , ** context )","title":"__init__()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.create_input","text":"Create http data input. Parameters: Name Type Description Default name str HTTP data input name. required stanza dict Data input stanza content. required Returns: Type Description dict Created input. Examples: >>> from solnlib.hec_config import HECConfig >>> hec = HECConfig ( session_key ) >>> hec . create_input ( 'my_hec_data_input' , { 'index' : 'main' , 'sourcetype' : 'hec' }) Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def create_input ( self , name : str , stanza : dict ) -> dict : \"\"\"Create http data input. Arguments: name: HTTP data input name. stanza: Data input stanza content. Returns: Created input. Examples: >>> from solnlib.hec_config import HECConfig >>> hec = HECConfig(session_key) >>> hec.create_input('my_hec_data_input', {'index': 'main', 'sourcetype': 'hec'}) \"\"\" res = self . _rest_client . inputs . create ( name , self . input_type , ** stanza ) return res . content","title":"create_input()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.delete_input","text":"Delete http data input. Parameters: Name Type Description Default name str HTTP data input name. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def delete_input ( self , name : str ): \"\"\"Delete http data input. Arguments: name: HTTP data input name. \"\"\" try : self . _rest_client . inputs . delete ( name , self . input_type ) except KeyError : pass","title":"delete_input()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_input","text":"Get http data input. Parameters: Name Type Description Default name str HTTP event collector data input name. required Returns: Type Description dict HTTP event collector data input config dict. Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_input ( self , name : str ) -> dict : \"\"\"Get http data input. Arguments: name: HTTP event collector data input name. Returns: HTTP event collector data input config dict. \"\"\" res = self . _do_get_input ( name ) if res : return res . content else : return None","title":"get_input()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_limits","text":"Get HTTP input limits. Returns: Type Description dict HTTP input limits. Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_limits ( self ) -> dict : \"\"\"Get HTTP input limits. Returns: HTTP input limits. \"\"\" return self . _rest_client . confs [ \"limits\" ][ \"http_input\" ] . content","title":"get_limits()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_settings","text":"Get http data input global settings. Returns: Type Description HTTP global settings, for example { \u2018enableSSL\u2019: 1, \u2018disabled\u2019: 0, \u2018useDeploymentServer\u2019: 0, \u2018port\u2019: 8088 } Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def get_settings ( self ) -> dict : \"\"\"Get http data input global settings. Returns: HTTP global settings, for example: { 'enableSSL': 1, 'disabled': 0, 'useDeploymentServer': 0, 'port': 8088 } \"\"\" return self . _do_get_input ( self . input_type ) . content","title":"get_settings()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.set_limits","text":"Set HTTP input limits. Parameters: Name Type Description Default limits dict HTTP input limits. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def set_limits ( self , limits : dict ): \"\"\"Set HTTP input limits. Arguments: limits: HTTP input limits. \"\"\" res = self . _rest_client . confs [ \"limits\" ][ \"http_input\" ] res . submit ( limits )","title":"set_limits()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.update_input","text":"Update http data input. It will create if the data input doesn\u2019t exist. Parameters: Name Type Description Default name str HTTP data input name. required stanza dict Data input stanza. required Examples: >>> from solnlib import HEConfig >>> hec = HECConfig ( session_key ) >>> hec . update_input ( 'my_hec_data_input' , { 'index' : 'main' , 'sourcetype' : 'hec2' }) Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def update_input ( self , name : str , stanza : dict ): \"\"\"Update http data input. It will create if the data input doesn't exist. Arguments: name: HTTP data input name. stanza: Data input stanza. Examples: >>> from solnlib import HEConfig >>> hec = HECConfig(session_key) >>> hec.update_input('my_hec_data_input', {'index': 'main', 'sourcetype': 'hec2'}) \"\"\" res = self . _do_get_input ( name ) if res is None : return self . create_input ( name , stanza ) res . update ( ** stanza )","title":"update_input()"},{"location":"hec_config/#solnlib.hec_config.HECConfig.update_settings","text":"Update http data input global settings. Parameters: Name Type Description Default settings dict HTTP global settings. required Source code in solnlib/hec_config.py @retry ( exceptions = [ binding . HTTPError ]) def update_settings ( self , settings : dict ): \"\"\"Update http data input global settings. Arguments: settings: HTTP global settings. \"\"\" res = self . _do_get_input ( self . input_type ) res . update ( ** settings )","title":"update_settings()"},{"location":"log/","text":"This module provides log functionalities. __all__ special \u00b6 LogException ( Exception ) \u00b6 Exception raised by Logs class. Logs \u00b6 A singleton class that manage all kinds of logger. Examples: >>> from solnlib.import log >>> log . Logs . set_context ( directory = '/var/log/test' , namespace = 'test' ) >>> logger = log . Logs () . get_logger ( 'mymodule' ) >>> logger . set_level ( logging . DEBUG ) >>> logger . debug ( 'a debug log' ) __init__ ( self ) special \u00b6 Source code in solnlib/log.py def __init__ ( self ): self . _lock = Lock () self . _loggers = {} get_logger ( self , name ) \u00b6 Get logger with the name of name . If logger with the name of name exists just return else create a new logger with the name of name . Parameters: Name Type Description Default name str Logger name, it will be used as log file name too. required Returns: Type Description Logger A named logger. Source code in solnlib/log.py def get_logger ( self , name : str ) -> logging . Logger : \"\"\"Get logger with the name of `name`. If logger with the name of `name` exists just return else create a new logger with the name of `name`. Arguments: name: Logger name, it will be used as log file name too. Returns: A named logger. \"\"\" with self . _lock : log_file = self . _get_log_file ( name ) if log_file in self . _loggers : return self . _loggers [ log_file ] logger = logging . getLogger ( log_file ) handler_exists = any ( [ True for h in logger . handlers if h . baseFilename == log_file ] ) if not handler_exists : file_handler = logging . handlers . RotatingFileHandler ( log_file , mode = \"a\" , maxBytes = self . _default_max_bytes , backupCount = self . _default_backup_count , ) file_handler . setFormatter ( logging . Formatter ( self . _default_log_format )) logger . addHandler ( file_handler ) logger . setLevel ( self . _default_log_level ) logger . propagate = False self . _loggers [ log_file ] = logger return logger set_context ( ** context ) classmethod \u00b6 Set log context. List of keyword arguments: directory : Log directory , default is splunk log root directory . namespace : Logger namespace , default is None . log_format : Log format , default is `_default_log_format` . log_level : Log level , default is logging . INFO . max_bytes : The maximum log file size before rollover , default is 25000000. backup_count : The number of log files to retain , default is 5. root_logger_log_file : Root logger log file name , default is 'solnlib' . Parameters: Name Type Description Default context dict Keyword arguments. See list of arguments above. {} Source code in solnlib/log.py @classmethod def set_context ( cls , ** context : dict ): \"\"\"Set log context. List of keyword arguments: directory: Log directory, default is splunk log root directory. namespace: Logger namespace, default is None. log_format: Log format, default is `_default_log_format`. log_level: Log level, default is logging.INFO. max_bytes: The maximum log file size before rollover, default is 25000000. backup_count: The number of log files to retain,default is 5. root_logger_log_file: Root logger log file name, default is 'solnlib' . Arguments: context: Keyword arguments. See list of arguments above. \"\"\" if \"directory\" in context : cls . _default_directory = context [ \"directory\" ] if \"namespace\" in context : cls . _default_namespace = context [ \"namespace\" ] if \"log_format\" in context : cls . _default_log_format = context [ \"log_format\" ] if \"log_level\" in context : cls . _default_log_level = context [ \"log_level\" ] if \"max_bytes\" in context : cls . _default_max_bytes = context [ \"max_bytes\" ] if \"backup_count\" in context : cls . _default_backup_count = context [ \"backup_count\" ] if \"root_logger_log_file\" in context : cls . _default_root_logger_log_file = context [ \"root_logger_log_file\" ] cls . _reset_root_logger () set_level ( self , level , name = None ) \u00b6 Set log level of logger. Set log level of all logger if name is None else of logger with the name of name . Parameters: Name Type Description Default level int Log level to set. required name str The name of logger, default is None. None Source code in solnlib/log.py def set_level ( self , level : int , name : str = None ): \"\"\"Set log level of logger. Set log level of all logger if `name` is None else of logger with the name of `name`. Arguments: level: Log level to set. name: The name of logger, default is None. \"\"\" with self . _lock : if name : log_file = self . _get_log_file ( name ) logger = self . _loggers . get ( log_file ) if logger : logger . setLevel ( level ) else : self . _default_log_level = level for logger in list ( self . _loggers . values ()): logger . setLevel ( level ) logging . getLogger () . setLevel ( level ) log_enter_exit ( logger ) \u00b6 Decorator for logger to log function enter and exit. This decorator will generate a lot of debug log, please add this only when it is required. Parameters: Name Type Description Default logger Logger Logger to decorate. required Examples: >>> @log_enter_exit >>> def myfunc (): >>> doSomething () Source code in solnlib/log.py def log_enter_exit ( logger : logging . Logger ): \"\"\"Decorator for logger to log function enter and exit. This decorator will generate a lot of debug log, please add this only when it is required. Arguments: logger: Logger to decorate. Examples: >>> @log_enter_exit >>> def myfunc(): >>> doSomething() \"\"\" def log_decorator ( func ): def wrapper ( * args , ** kwargs ): logger . debug ( \" %s entered\" , func . __name__ ) result = func ( * args , ** kwargs ) logger . debug ( \" %s exited\" , func . __name__ ) return result return wrapper return log_decorator","title":"log.py"},{"location":"log/#solnlib.log.__all__","text":"","title":"__all__"},{"location":"log/#solnlib.log.LogException","text":"Exception raised by Logs class.","title":"LogException"},{"location":"log/#solnlib.log.Logs","text":"A singleton class that manage all kinds of logger. Examples: >>> from solnlib.import log >>> log . Logs . set_context ( directory = '/var/log/test' , namespace = 'test' ) >>> logger = log . Logs () . get_logger ( 'mymodule' ) >>> logger . set_level ( logging . DEBUG ) >>> logger . debug ( 'a debug log' )","title":"Logs"},{"location":"log/#solnlib.log.Logs.__init__","text":"Source code in solnlib/log.py def __init__ ( self ): self . _lock = Lock () self . _loggers = {}","title":"__init__()"},{"location":"log/#solnlib.log.Logs.get_logger","text":"Get logger with the name of name . If logger with the name of name exists just return else create a new logger with the name of name . Parameters: Name Type Description Default name str Logger name, it will be used as log file name too. required Returns: Type Description Logger A named logger. Source code in solnlib/log.py def get_logger ( self , name : str ) -> logging . Logger : \"\"\"Get logger with the name of `name`. If logger with the name of `name` exists just return else create a new logger with the name of `name`. Arguments: name: Logger name, it will be used as log file name too. Returns: A named logger. \"\"\" with self . _lock : log_file = self . _get_log_file ( name ) if log_file in self . _loggers : return self . _loggers [ log_file ] logger = logging . getLogger ( log_file ) handler_exists = any ( [ True for h in logger . handlers if h . baseFilename == log_file ] ) if not handler_exists : file_handler = logging . handlers . RotatingFileHandler ( log_file , mode = \"a\" , maxBytes = self . _default_max_bytes , backupCount = self . _default_backup_count , ) file_handler . setFormatter ( logging . Formatter ( self . _default_log_format )) logger . addHandler ( file_handler ) logger . setLevel ( self . _default_log_level ) logger . propagate = False self . _loggers [ log_file ] = logger return logger","title":"get_logger()"},{"location":"log/#solnlib.log.Logs.set_context","text":"Set log context. List of keyword arguments: directory : Log directory , default is splunk log root directory . namespace : Logger namespace , default is None . log_format : Log format , default is `_default_log_format` . log_level : Log level , default is logging . INFO . max_bytes : The maximum log file size before rollover , default is 25000000. backup_count : The number of log files to retain , default is 5. root_logger_log_file : Root logger log file name , default is 'solnlib' . Parameters: Name Type Description Default context dict Keyword arguments. See list of arguments above. {} Source code in solnlib/log.py @classmethod def set_context ( cls , ** context : dict ): \"\"\"Set log context. List of keyword arguments: directory: Log directory, default is splunk log root directory. namespace: Logger namespace, default is None. log_format: Log format, default is `_default_log_format`. log_level: Log level, default is logging.INFO. max_bytes: The maximum log file size before rollover, default is 25000000. backup_count: The number of log files to retain,default is 5. root_logger_log_file: Root logger log file name, default is 'solnlib' . Arguments: context: Keyword arguments. See list of arguments above. \"\"\" if \"directory\" in context : cls . _default_directory = context [ \"directory\" ] if \"namespace\" in context : cls . _default_namespace = context [ \"namespace\" ] if \"log_format\" in context : cls . _default_log_format = context [ \"log_format\" ] if \"log_level\" in context : cls . _default_log_level = context [ \"log_level\" ] if \"max_bytes\" in context : cls . _default_max_bytes = context [ \"max_bytes\" ] if \"backup_count\" in context : cls . _default_backup_count = context [ \"backup_count\" ] if \"root_logger_log_file\" in context : cls . _default_root_logger_log_file = context [ \"root_logger_log_file\" ] cls . _reset_root_logger ()","title":"set_context()"},{"location":"log/#solnlib.log.Logs.set_level","text":"Set log level of logger. Set log level of all logger if name is None else of logger with the name of name . Parameters: Name Type Description Default level int Log level to set. required name str The name of logger, default is None. None Source code in solnlib/log.py def set_level ( self , level : int , name : str = None ): \"\"\"Set log level of logger. Set log level of all logger if `name` is None else of logger with the name of `name`. Arguments: level: Log level to set. name: The name of logger, default is None. \"\"\" with self . _lock : if name : log_file = self . _get_log_file ( name ) logger = self . _loggers . get ( log_file ) if logger : logger . setLevel ( level ) else : self . _default_log_level = level for logger in list ( self . _loggers . values ()): logger . setLevel ( level ) logging . getLogger () . setLevel ( level )","title":"set_level()"},{"location":"log/#solnlib.log.log_enter_exit","text":"Decorator for logger to log function enter and exit. This decorator will generate a lot of debug log, please add this only when it is required. Parameters: Name Type Description Default logger Logger Logger to decorate. required Examples: >>> @log_enter_exit >>> def myfunc (): >>> doSomething () Source code in solnlib/log.py def log_enter_exit ( logger : logging . Logger ): \"\"\"Decorator for logger to log function enter and exit. This decorator will generate a lot of debug log, please add this only when it is required. Arguments: logger: Logger to decorate. Examples: >>> @log_enter_exit >>> def myfunc(): >>> doSomething() \"\"\" def log_decorator ( func ): def wrapper ( * args , ** kwargs ): logger . debug ( \" %s entered\" , func . __name__ ) result = func ( * args , ** kwargs ) logger . debug ( \" %s exited\" , func . __name__ ) return result return wrapper return log_decorator","title":"log_enter_exit()"},{"location":"net_utils/","text":"Net utilities. __all__ special \u00b6 is_valid_hostname ( hostname ) \u00b6 Validate a host name. Parameters: Name Type Description Default hostname str host name to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_hostname ( hostname : str ) -> bool : \"\"\"Validate a host name. Arguments: hostname: host name to validate. Returns: True if is valid else False. \"\"\" if len ( hostname ) > 255 : return False if hostname [ - 1 :] == \".\" : hostname = hostname [: - 1 ] allowed = re . compile ( r \"(?!-)(::)?[A-Z\\d-]{1,63}(?<!-)$\" , re . IGNORECASE ) return all ( allowed . match ( x ) for x in hostname . split ( \".\" )) is_valid_ip ( addr ) \u00b6 Validate an IPV4 address. Parameters: Name Type Description Default addr str IP address to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_ip ( addr : str ) -> bool : \"\"\"Validate an IPV4 address. Arguments: addr: IP address to validate. Returns: True if is valid else False. \"\"\" ip_rx = re . compile ( r \"\"\" ^((( [0-1]\\d{2} # matches 000-199 | 2[0-4]\\d # matches 200-249 | 25[0-5] # matches 250-255 | \\d{1,2} # matches 0-9, 00-99 )\\.){3}) # 3 of the preceding stanzas ([0-1]\\d{2}|2[0-4]\\d|25[0-5]|\\d{1,2})$ # final octet \"\"\" , re . VERBOSE , ) try : return ip_rx . match ( addr . strip ()) except AttributeError : # Value was not a string return False is_valid_port ( port ) \u00b6 Validate a port. Parameters: Name Type Description Default port Union[str, int] port to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_port ( port : Union [ str , int ]) -> bool : \"\"\"Validate a port. Arguments: port: port to validate. Returns: True if is valid else False. \"\"\" try : return 0 < int ( port ) <= 65535 except ValueError : return False is_valid_scheme ( scheme ) \u00b6 Validate a scheme. Parameters: Name Type Description Default scheme str scheme to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_scheme ( scheme : str ) -> bool : \"\"\"Validate a scheme. Arguments: scheme: scheme to validate. Returns: True if is valid else False. \"\"\" return scheme . lower () in ( \"http\" , \"https\" ) resolve_hostname ( addr ) \u00b6 Try to resolve an IP to a host name and returns None on common failures. Parameters: Name Type Description Default addr str IP address to resolve. required Returns: Type Description Optional[str] Host name if success else None. Exceptions: Type Description ValueError If addr is not a valid address. Source code in solnlib/net_utils.py def resolve_hostname ( addr : str ) -> Optional [ str ]: \"\"\"Try to resolve an IP to a host name and returns None on common failures. Arguments: addr: IP address to resolve. Returns: Host name if success else None. Raises: ValueError: If `addr` is not a valid address. \"\"\" if is_valid_ip ( addr ): try : name , _ , _ = socket . gethostbyaddr ( addr ) return name except socket . gaierror : # [Errno 8] nodename nor servname provided, or not known pass except socket . herror : # [Errno 1] Unknown host pass except socket . timeout : # Timeout. pass return None else : raise ValueError ( \"Invalid ip address.\" ) validate_scheme_host_port ( scheme , host , port ) \u00b6 Validates scheme, host and port. Parameters: Name Type Description Default scheme str scheme to validate. required host str hostname to validate. required port Union[str, int] port to validate. required Exceptions: Type Description ValueError if scheme, host or port are invalid. Source code in solnlib/net_utils.py def validate_scheme_host_port ( scheme : str , host : str , port : Union [ str , int ]): \"\"\"Validates scheme, host and port. Arguments: scheme: scheme to validate. host: hostname to validate. port: port to validate. Raises: ValueError: if scheme, host or port are invalid. \"\"\" if scheme is not None and not is_valid_scheme ( scheme ): raise ValueError ( \"Invalid scheme\" ) if host is not None and not is_valid_hostname ( host ): raise ValueError ( \"Invalid host\" ) if port is not None and not is_valid_port ( port ): raise ValueError ( \"Invalid port\" )","title":"net_utils.py"},{"location":"net_utils/#solnlib.net_utils.__all__","text":"","title":"__all__"},{"location":"net_utils/#solnlib.net_utils.is_valid_hostname","text":"Validate a host name. Parameters: Name Type Description Default hostname str host name to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_hostname ( hostname : str ) -> bool : \"\"\"Validate a host name. Arguments: hostname: host name to validate. Returns: True if is valid else False. \"\"\" if len ( hostname ) > 255 : return False if hostname [ - 1 :] == \".\" : hostname = hostname [: - 1 ] allowed = re . compile ( r \"(?!-)(::)?[A-Z\\d-]{1,63}(?<!-)$\" , re . IGNORECASE ) return all ( allowed . match ( x ) for x in hostname . split ( \".\" ))","title":"is_valid_hostname()"},{"location":"net_utils/#solnlib.net_utils.is_valid_ip","text":"Validate an IPV4 address. Parameters: Name Type Description Default addr str IP address to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_ip ( addr : str ) -> bool : \"\"\"Validate an IPV4 address. Arguments: addr: IP address to validate. Returns: True if is valid else False. \"\"\" ip_rx = re . compile ( r \"\"\" ^((( [0-1]\\d{2} # matches 000-199 | 2[0-4]\\d # matches 200-249 | 25[0-5] # matches 250-255 | \\d{1,2} # matches 0-9, 00-99 )\\.){3}) # 3 of the preceding stanzas ([0-1]\\d{2}|2[0-4]\\d|25[0-5]|\\d{1,2})$ # final octet \"\"\" , re . VERBOSE , ) try : return ip_rx . match ( addr . strip ()) except AttributeError : # Value was not a string return False","title":"is_valid_ip()"},{"location":"net_utils/#solnlib.net_utils.is_valid_port","text":"Validate a port. Parameters: Name Type Description Default port Union[str, int] port to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_port ( port : Union [ str , int ]) -> bool : \"\"\"Validate a port. Arguments: port: port to validate. Returns: True if is valid else False. \"\"\" try : return 0 < int ( port ) <= 65535 except ValueError : return False","title":"is_valid_port()"},{"location":"net_utils/#solnlib.net_utils.is_valid_scheme","text":"Validate a scheme. Parameters: Name Type Description Default scheme str scheme to validate. required Returns: Type Description bool True if is valid else False. Source code in solnlib/net_utils.py def is_valid_scheme ( scheme : str ) -> bool : \"\"\"Validate a scheme. Arguments: scheme: scheme to validate. Returns: True if is valid else False. \"\"\" return scheme . lower () in ( \"http\" , \"https\" )","title":"is_valid_scheme()"},{"location":"net_utils/#solnlib.net_utils.resolve_hostname","text":"Try to resolve an IP to a host name and returns None on common failures. Parameters: Name Type Description Default addr str IP address to resolve. required Returns: Type Description Optional[str] Host name if success else None. Exceptions: Type Description ValueError If addr is not a valid address. Source code in solnlib/net_utils.py def resolve_hostname ( addr : str ) -> Optional [ str ]: \"\"\"Try to resolve an IP to a host name and returns None on common failures. Arguments: addr: IP address to resolve. Returns: Host name if success else None. Raises: ValueError: If `addr` is not a valid address. \"\"\" if is_valid_ip ( addr ): try : name , _ , _ = socket . gethostbyaddr ( addr ) return name except socket . gaierror : # [Errno 8] nodename nor servname provided, or not known pass except socket . herror : # [Errno 1] Unknown host pass except socket . timeout : # Timeout. pass return None else : raise ValueError ( \"Invalid ip address.\" )","title":"resolve_hostname()"},{"location":"net_utils/#solnlib.net_utils.validate_scheme_host_port","text":"Validates scheme, host and port. Parameters: Name Type Description Default scheme str scheme to validate. required host str hostname to validate. required port Union[str, int] port to validate. required Exceptions: Type Description ValueError if scheme, host or port are invalid. Source code in solnlib/net_utils.py def validate_scheme_host_port ( scheme : str , host : str , port : Union [ str , int ]): \"\"\"Validates scheme, host and port. Arguments: scheme: scheme to validate. host: hostname to validate. port: port to validate. Raises: ValueError: if scheme, host or port are invalid. \"\"\" if scheme is not None and not is_valid_scheme ( scheme ): raise ValueError ( \"Invalid scheme\" ) if host is not None and not is_valid_hostname ( host ): raise ValueError ( \"Invalid host\" ) if port is not None and not is_valid_port ( port ): raise ValueError ( \"Invalid port\" )","title":"validate_scheme_host_port()"},{"location":"orphan_process_monitor/","text":"Orphan process monitor. __all__ special \u00b6 OrphanProcessChecker \u00b6 Orphan process checker. Only work for Linux platform. On Windows platform, is_orphan is always False and there is no need to do this monitoring on Windows. __init__ ( self , callback = None ) special \u00b6 Initializes OrphanProcessChecker. Parameters: Name Type Description Default callback Callable (optional) Callback for orphan process. None Source code in solnlib/orphan_process_monitor.py def __init__ ( self , callback : Callable = None ): \"\"\"Initializes OrphanProcessChecker. Arguments: callback: (optional) Callback for orphan process. \"\"\" if os . name == \"nt\" : self . _ppid = 0 else : self . _ppid = os . getppid () self . _callback = callback check_orphan ( self ) \u00b6 Check if the process becomes orphan. If the process becomes orphan then call callback function to handle properly. Returns: Type Description bool True for orphan process else False. Source code in solnlib/orphan_process_monitor.py def check_orphan ( self ) -> bool : \"\"\"Check if the process becomes orphan. If the process becomes orphan then call callback function to handle properly. Returns: True for orphan process else False. \"\"\" res = self . is_orphan () if res and self . _callback : self . _callback () return res is_orphan ( self ) \u00b6 Check process is orphan. For windows platform just return False. Returns: Type Description bool True for orphan process else False. Source code in solnlib/orphan_process_monitor.py def is_orphan ( self ) -> bool : \"\"\"Check process is orphan. For windows platform just return False. Returns: True for orphan process else False. \"\"\" if os . name == \"nt\" : return False return self . _ppid != os . getppid () OrphanProcessMonitor \u00b6 Orphan process monitor. Check if process become orphan in background thread per interval and call callback if process become orphan. __init__ ( self , callback , interval = 1 ) special \u00b6 Initializes OrphanProcessMonitor. Parameters: Name Type Description Default callback Callable Callback for orphan process monitor. required interval int (optional) Interval to monitor. 1 Source code in solnlib/orphan_process_monitor.py def __init__ ( self , callback : Callable , interval : int = 1 ): \"\"\"Initializes OrphanProcessMonitor. Arguments: callback: Callback for orphan process monitor. interval: (optional) Interval to monitor. \"\"\" self . _checker = OrphanProcessChecker ( callback ) self . _thr = threading . Thread ( target = self . _do_monitor ) self . _thr . daemon = True self . _started = False self . _interval = interval start ( self ) \u00b6 Start orphan process monitor. Source code in solnlib/orphan_process_monitor.py def start ( self ): \"\"\"Start orphan process monitor.\"\"\" if self . _started : return self . _started = True self . _thr . start () stop ( self ) \u00b6 Stop orphan process monitor. Source code in solnlib/orphan_process_monitor.py def stop ( self ): \"\"\"Stop orphan process monitor.\"\"\" joinable = self . _started self . _started = False if joinable : self . _thr . join ( timeout = 1 )","title":"orphan_process_monitor.py"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.__all__","text":"","title":"__all__"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker","text":"Orphan process checker. Only work for Linux platform. On Windows platform, is_orphan is always False and there is no need to do this monitoring on Windows.","title":"OrphanProcessChecker"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.__init__","text":"Initializes OrphanProcessChecker. Parameters: Name Type Description Default callback Callable (optional) Callback for orphan process. None Source code in solnlib/orphan_process_monitor.py def __init__ ( self , callback : Callable = None ): \"\"\"Initializes OrphanProcessChecker. Arguments: callback: (optional) Callback for orphan process. \"\"\" if os . name == \"nt\" : self . _ppid = 0 else : self . _ppid = os . getppid () self . _callback = callback","title":"__init__()"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.check_orphan","text":"Check if the process becomes orphan. If the process becomes orphan then call callback function to handle properly. Returns: Type Description bool True for orphan process else False. Source code in solnlib/orphan_process_monitor.py def check_orphan ( self ) -> bool : \"\"\"Check if the process becomes orphan. If the process becomes orphan then call callback function to handle properly. Returns: True for orphan process else False. \"\"\" res = self . is_orphan () if res and self . _callback : self . _callback () return res","title":"check_orphan()"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.is_orphan","text":"Check process is orphan. For windows platform just return False. Returns: Type Description bool True for orphan process else False. Source code in solnlib/orphan_process_monitor.py def is_orphan ( self ) -> bool : \"\"\"Check process is orphan. For windows platform just return False. Returns: True for orphan process else False. \"\"\" if os . name == \"nt\" : return False return self . _ppid != os . getppid ()","title":"is_orphan()"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor","text":"Orphan process monitor. Check if process become orphan in background thread per interval and call callback if process become orphan.","title":"OrphanProcessMonitor"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.__init__","text":"Initializes OrphanProcessMonitor. Parameters: Name Type Description Default callback Callable Callback for orphan process monitor. required interval int (optional) Interval to monitor. 1 Source code in solnlib/orphan_process_monitor.py def __init__ ( self , callback : Callable , interval : int = 1 ): \"\"\"Initializes OrphanProcessMonitor. Arguments: callback: Callback for orphan process monitor. interval: (optional) Interval to monitor. \"\"\" self . _checker = OrphanProcessChecker ( callback ) self . _thr = threading . Thread ( target = self . _do_monitor ) self . _thr . daemon = True self . _started = False self . _interval = interval","title":"__init__()"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.start","text":"Start orphan process monitor. Source code in solnlib/orphan_process_monitor.py def start ( self ): \"\"\"Start orphan process monitor.\"\"\" if self . _started : return self . _started = True self . _thr . start ()","title":"start()"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.stop","text":"Stop orphan process monitor. Source code in solnlib/orphan_process_monitor.py def stop ( self ): \"\"\"Stop orphan process monitor.\"\"\" joinable = self . _started self . _started = False if joinable : self . _thr . join ( timeout = 1 )","title":"stop()"},{"location":"pattern/","text":"This module provides some common used patterns. __all__ special \u00b6 Singleton ( type ) \u00b6 Singleton meta class. Examples: >>> class Test ( object ): >>> __metaclass__ = Singleton >>> >>> def __init__ ( self ): >>> pass __call__ ( cls , * args , ** kwargs ) special \u00b6 Source code in solnlib/pattern.py def __call__ ( cls , * args , ** kwargs ): if cls . _instance is None : cls . _instance = super () . __call__ ( * args , ** kwargs ) return cls . _instance __init__ ( cls , name , bases , attrs ) special \u00b6 Source code in solnlib/pattern.py def __init__ ( cls , name , bases , attrs ): super () . __init__ ( name , bases , attrs ) cls . _instance = None","title":"pattern.py"},{"location":"pattern/#solnlib.pattern.__all__","text":"","title":"__all__"},{"location":"pattern/#solnlib.pattern.Singleton","text":"Singleton meta class. Examples: >>> class Test ( object ): >>> __metaclass__ = Singleton >>> >>> def __init__ ( self ): >>> pass","title":"Singleton"},{"location":"pattern/#solnlib.pattern.Singleton.__call__","text":"Source code in solnlib/pattern.py def __call__ ( cls , * args , ** kwargs ): if cls . _instance is None : cls . _instance = super () . __call__ ( * args , ** kwargs ) return cls . _instance","title":"__call__()"},{"location":"pattern/#solnlib.pattern.Singleton.__init__","text":"Source code in solnlib/pattern.py def __init__ ( cls , name , bases , attrs ): super () . __init__ ( name , bases , attrs ) cls . _instance = None","title":"__init__()"},{"location":"server_info/","text":"This module contains Splunk server info related functionalities. __all__ special \u00b6 ServerInfo \u00b6 This class is a wrapper of Splunk server info. SHC_CAPTAIN_INFO_ENDPOINT \u00b6 SHC_MEMBER_ENDPOINT \u00b6 guid : str property readonly \u00b6 Get guid for the server. Returns: Type Description str Server GUID. server_name : str property readonly \u00b6 Get server name. Returns: Type Description str Server name. version : str property readonly \u00b6 Get Splunk server version. Returns: Type Description str Splunk version. __init__ ( self , session_key , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes ServerInfo. Parameters: Name Type Description Default session_key str Splunk access token. required scheme Optional[str] The access scheme, default is None. None host Optional[str] The host name, default is None. None port Optional[int] The port number, default is None. None context Any Other configurations for Splunk rest client. {} Source code in solnlib/server_info.py def __init__ ( self , session_key : str , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : Any ): \"\"\"Initializes ServerInfo. Arguments: session_key: Splunk access token. scheme: The access scheme, default is None. host: The host name, default is None. port: The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) captain_info ( self ) \u00b6 Get captain information. Exceptions: Type Description ServerInfoException If there is SHC is not enabled. Returns: Type Description dict Captain information. Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def captain_info ( self ) -> dict : \"\"\"Get captain information. Raises: ServerInfoException: If there is SHC is not enabled. Returns: Captain information. \"\"\" try : content = self . _rest_client . get ( self . SHC_CAPTAIN_INFO_ENDPOINT , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status == 503 and \"not available\" in str ( e ): raise ServerInfoException ( str ( e )) raise return json . loads ( content )[ \"entry\" ][ 0 ][ \"content\" ] from_server_uri ( server_uri , session_key , ** context ) classmethod \u00b6 Creates ServerInfo class using server_uri and session_key. Note: splunktalib uses these parameters to create it\u2019s ServerInfo class, so this method should ease the transition from splunktalib to solnlib. Parameters: Name Type Description Default server_uri str splunkd URI. required session_key str Splunk access token. required context Any Other configurations for Splunk rest client. {} Returns: Type Description ServerInfo An instance of ServerInfo . Exceptions: Type Description ValueError server_uri is in the wrong format. Source code in solnlib/server_info.py @classmethod def from_server_uri ( cls , server_uri : str , session_key : str , ** context : Any ) -> \"ServerInfo\" : \"\"\"Creates ServerInfo class using server_uri and session_key. Note: splunktalib uses these parameters to create it's ServerInfo class, so this method should ease the transition from splunktalib to solnlib. Arguments: server_uri: splunkd URI. session_key: Splunk access token. context: Other configurations for Splunk rest client. Returns: An instance of `ServerInfo`. Raises: ValueError: server_uri is in the wrong format. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( server_uri ) return ServerInfo ( session_key , scheme = scheme , host = host , port = port , ** context , ) get_shc_members ( self ) \u00b6 Get SHC members. Exceptions: Type Description ServerInfoException If this server has no SHC members. Returns: Type Description list List of SHC members [(label, peer_scheme_host_port) \u2026]. Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_shc_members ( self ) -> list : \"\"\"Get SHC members. Raises: ServerInfoException: If this server has no SHC members. Returns: List of SHC members [(label, peer_scheme_host_port) ...]. \"\"\" try : content = self . _rest_client . get ( self . SHC_MEMBER_ENDPOINT , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 and e . status != 503 : raise raise ServerInfoException ( \"This server is not a SHC member and has no SHC members.\" ) members = [] for member in json . loads ( content )[ \"entry\" ]: content = member [ \"content\" ] members . append (( content [ \"label\" ], content [ \"peer_scheme_host_port\" ])) return members is_captain ( self ) \u00b6 Check if this server is SHC captain. Note during a rolling start of SH members, the captain may be changed from machine to machine. To avoid the race condition, client may need do necessary sleep and then poll is_captain_ready() == True and then check is_captain() . See is_captain_ready() for more details. Returns: Type Description bool True if this server is SHC captain else False. Source code in solnlib/server_info.py def is_captain ( self ) -> bool : \"\"\"Check if this server is SHC captain. Note during a rolling start of SH members, the captain may be changed from machine to machine. To avoid the race condition, client may need do necessary sleep and then poll `is_captain_ready() == True` and then check `is_captain()`. See `is_captain_ready()` for more details. Returns: True if this server is SHC captain else False. \"\"\" return \"shc_captain\" in self . _server_info ()[ \"server_roles\" ] is_captain_ready ( self ) \u00b6 Check if captain is ready. Client usually first polls this function until captain is ready and then call is_captain to detect current captain machine Returns: Type Description bool True if captain is ready else False. Examples: >>> from solnlib import server_info >>> serverinfo = server_info . ServerInfo ( session_key ) >>> while 1 : >>> if serverinfo . is_captain_ready (): >>> break >>> time . sleep ( 2 ) >>> >>> # If do_stuff can only be executed in SH captain >>> if serverinfo . is_captain (): >>> do_stuff () Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def is_captain_ready ( self ) -> bool : \"\"\"Check if captain is ready. Client usually first polls this function until captain is ready and then call is_captain to detect current captain machine Returns: True if captain is ready else False. Examples: >>> from solnlib import server_info >>> serverinfo = server_info.ServerInfo(session_key) >>> while 1: >>> if serverinfo.is_captain_ready(): >>> break >>> time.sleep(2) >>> >>> # If do_stuff can only be executed in SH captain >>> if serverinfo.is_captain(): >>> do_stuff() \"\"\" cap_info = self . captain_info () return utils . is_true ( cap_info [ \"service_ready_flag\" ]) and utils . is_false ( cap_info [ \"maintenance_mode\" ] ) is_cloud_instance ( self ) \u00b6 Check if this server is a cloud instance. Returns: Type Description bool True if this server is a cloud instance else False. Source code in solnlib/server_info.py def is_cloud_instance ( self ) -> bool : \"\"\"Check if this server is a cloud instance. Returns: True if this server is a cloud instance else False. \"\"\" try : return self . _server_info ()[ \"instance_type\" ] == \"cloud\" except KeyError : return False is_search_head ( self ) \u00b6 Check if this server is a search head. Returns: Type Description bool True if this server is a search head else False. Source code in solnlib/server_info.py def is_search_head ( self ) -> bool : \"\"\"Check if this server is a search head. Returns: True if this server is a search head else False. \"\"\" server_info = self . _server_info () for sh in ( \"search_head\" , \"cluster_search_head\" ): if sh in server_info [ \"server_roles\" ]: return True return False is_shc_member ( self ) \u00b6 Check if this server is a SHC member. Returns: Type Description bool True if this server is a SHC member else False. Source code in solnlib/server_info.py def is_shc_member ( self ) -> bool : \"\"\"Check if this server is a SHC member. Returns: True if this server is a SHC member else False. \"\"\" server_info = self . _server_info () for sh in ( \"shc_member\" , \"shc_captain\" ): if sh in server_info [ \"server_roles\" ]: return True return False to_dict ( self ) \u00b6 Returns server information in a form dictionary. Note: This method is implemented here to have compatibility with splunktalib\u2019s analogue. Returns: Type Description Dict Server information in a dictionary format. Source code in solnlib/server_info.py def to_dict ( self ) -> Dict : \"\"\"Returns server information in a form dictionary. Note: This method is implemented here to have compatibility with splunktalib's analogue. Returns: Server information in a dictionary format. \"\"\" return self . _server_info () ServerInfoException ( Exception ) \u00b6 Exception raised by ServerInfo class.","title":"server_info.py"},{"location":"server_info/#solnlib.server_info.__all__","text":"","title":"__all__"},{"location":"server_info/#solnlib.server_info.ServerInfo","text":"This class is a wrapper of Splunk server info.","title":"ServerInfo"},{"location":"server_info/#solnlib.server_info.ServerInfo.SHC_CAPTAIN_INFO_ENDPOINT","text":"","title":"SHC_CAPTAIN_INFO_ENDPOINT"},{"location":"server_info/#solnlib.server_info.ServerInfo.SHC_MEMBER_ENDPOINT","text":"","title":"SHC_MEMBER_ENDPOINT"},{"location":"server_info/#solnlib.server_info.ServerInfo.guid","text":"Get guid for the server. Returns: Type Description str Server GUID.","title":"guid"},{"location":"server_info/#solnlib.server_info.ServerInfo.server_name","text":"Get server name. Returns: Type Description str Server name.","title":"server_name"},{"location":"server_info/#solnlib.server_info.ServerInfo.version","text":"Get Splunk server version. Returns: Type Description str Splunk version.","title":"version"},{"location":"server_info/#solnlib.server_info.ServerInfo.__init__","text":"Initializes ServerInfo. Parameters: Name Type Description Default session_key str Splunk access token. required scheme Optional[str] The access scheme, default is None. None host Optional[str] The host name, default is None. None port Optional[int] The port number, default is None. None context Any Other configurations for Splunk rest client. {} Source code in solnlib/server_info.py def __init__ ( self , session_key : str , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : Any ): \"\"\"Initializes ServerInfo. Arguments: session_key: Splunk access token. scheme: The access scheme, default is None. host: The host name, default is None. port: The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context )","title":"__init__()"},{"location":"server_info/#solnlib.server_info.ServerInfo.captain_info","text":"Get captain information. Exceptions: Type Description ServerInfoException If there is SHC is not enabled. Returns: Type Description dict Captain information. Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def captain_info ( self ) -> dict : \"\"\"Get captain information. Raises: ServerInfoException: If there is SHC is not enabled. Returns: Captain information. \"\"\" try : content = self . _rest_client . get ( self . SHC_CAPTAIN_INFO_ENDPOINT , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status == 503 and \"not available\" in str ( e ): raise ServerInfoException ( str ( e )) raise return json . loads ( content )[ \"entry\" ][ 0 ][ \"content\" ]","title":"captain_info()"},{"location":"server_info/#solnlib.server_info.ServerInfo.from_server_uri","text":"Creates ServerInfo class using server_uri and session_key. Note: splunktalib uses these parameters to create it\u2019s ServerInfo class, so this method should ease the transition from splunktalib to solnlib. Parameters: Name Type Description Default server_uri str splunkd URI. required session_key str Splunk access token. required context Any Other configurations for Splunk rest client. {} Returns: Type Description ServerInfo An instance of ServerInfo . Exceptions: Type Description ValueError server_uri is in the wrong format. Source code in solnlib/server_info.py @classmethod def from_server_uri ( cls , server_uri : str , session_key : str , ** context : Any ) -> \"ServerInfo\" : \"\"\"Creates ServerInfo class using server_uri and session_key. Note: splunktalib uses these parameters to create it's ServerInfo class, so this method should ease the transition from splunktalib to solnlib. Arguments: server_uri: splunkd URI. session_key: Splunk access token. context: Other configurations for Splunk rest client. Returns: An instance of `ServerInfo`. Raises: ValueError: server_uri is in the wrong format. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( server_uri ) return ServerInfo ( session_key , scheme = scheme , host = host , port = port , ** context , )","title":"from_server_uri()"},{"location":"server_info/#solnlib.server_info.ServerInfo.get_shc_members","text":"Get SHC members. Exceptions: Type Description ServerInfoException If this server has no SHC members. Returns: Type Description list List of SHC members [(label, peer_scheme_host_port) \u2026]. Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_shc_members ( self ) -> list : \"\"\"Get SHC members. Raises: ServerInfoException: If this server has no SHC members. Returns: List of SHC members [(label, peer_scheme_host_port) ...]. \"\"\" try : content = self . _rest_client . get ( self . SHC_MEMBER_ENDPOINT , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 and e . status != 503 : raise raise ServerInfoException ( \"This server is not a SHC member and has no SHC members.\" ) members = [] for member in json . loads ( content )[ \"entry\" ]: content = member [ \"content\" ] members . append (( content [ \"label\" ], content [ \"peer_scheme_host_port\" ])) return members","title":"get_shc_members()"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_captain","text":"Check if this server is SHC captain. Note during a rolling start of SH members, the captain may be changed from machine to machine. To avoid the race condition, client may need do necessary sleep and then poll is_captain_ready() == True and then check is_captain() . See is_captain_ready() for more details. Returns: Type Description bool True if this server is SHC captain else False. Source code in solnlib/server_info.py def is_captain ( self ) -> bool : \"\"\"Check if this server is SHC captain. Note during a rolling start of SH members, the captain may be changed from machine to machine. To avoid the race condition, client may need do necessary sleep and then poll `is_captain_ready() == True` and then check `is_captain()`. See `is_captain_ready()` for more details. Returns: True if this server is SHC captain else False. \"\"\" return \"shc_captain\" in self . _server_info ()[ \"server_roles\" ]","title":"is_captain()"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_captain_ready","text":"Check if captain is ready. Client usually first polls this function until captain is ready and then call is_captain to detect current captain machine Returns: Type Description bool True if captain is ready else False. Examples: >>> from solnlib import server_info >>> serverinfo = server_info . ServerInfo ( session_key ) >>> while 1 : >>> if serverinfo . is_captain_ready (): >>> break >>> time . sleep ( 2 ) >>> >>> # If do_stuff can only be executed in SH captain >>> if serverinfo . is_captain (): >>> do_stuff () Source code in solnlib/server_info.py @utils . retry ( exceptions = [ binding . HTTPError ]) def is_captain_ready ( self ) -> bool : \"\"\"Check if captain is ready. Client usually first polls this function until captain is ready and then call is_captain to detect current captain machine Returns: True if captain is ready else False. Examples: >>> from solnlib import server_info >>> serverinfo = server_info.ServerInfo(session_key) >>> while 1: >>> if serverinfo.is_captain_ready(): >>> break >>> time.sleep(2) >>> >>> # If do_stuff can only be executed in SH captain >>> if serverinfo.is_captain(): >>> do_stuff() \"\"\" cap_info = self . captain_info () return utils . is_true ( cap_info [ \"service_ready_flag\" ]) and utils . is_false ( cap_info [ \"maintenance_mode\" ] )","title":"is_captain_ready()"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_cloud_instance","text":"Check if this server is a cloud instance. Returns: Type Description bool True if this server is a cloud instance else False. Source code in solnlib/server_info.py def is_cloud_instance ( self ) -> bool : \"\"\"Check if this server is a cloud instance. Returns: True if this server is a cloud instance else False. \"\"\" try : return self . _server_info ()[ \"instance_type\" ] == \"cloud\" except KeyError : return False","title":"is_cloud_instance()"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_search_head","text":"Check if this server is a search head. Returns: Type Description bool True if this server is a search head else False. Source code in solnlib/server_info.py def is_search_head ( self ) -> bool : \"\"\"Check if this server is a search head. Returns: True if this server is a search head else False. \"\"\" server_info = self . _server_info () for sh in ( \"search_head\" , \"cluster_search_head\" ): if sh in server_info [ \"server_roles\" ]: return True return False","title":"is_search_head()"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_shc_member","text":"Check if this server is a SHC member. Returns: Type Description bool True if this server is a SHC member else False. Source code in solnlib/server_info.py def is_shc_member ( self ) -> bool : \"\"\"Check if this server is a SHC member. Returns: True if this server is a SHC member else False. \"\"\" server_info = self . _server_info () for sh in ( \"shc_member\" , \"shc_captain\" ): if sh in server_info [ \"server_roles\" ]: return True return False","title":"is_shc_member()"},{"location":"server_info/#solnlib.server_info.ServerInfo.to_dict","text":"Returns server information in a form dictionary. Note: This method is implemented here to have compatibility with splunktalib\u2019s analogue. Returns: Type Description Dict Server information in a dictionary format. Source code in solnlib/server_info.py def to_dict ( self ) -> Dict : \"\"\"Returns server information in a form dictionary. Note: This method is implemented here to have compatibility with splunktalib's analogue. Returns: Server information in a dictionary format. \"\"\" return self . _server_info ()","title":"to_dict()"},{"location":"server_info/#solnlib.server_info.ServerInfoException","text":"Exception raised by ServerInfo class.","title":"ServerInfoException"},{"location":"splunk_rest_client/","text":"This module proxy all REST call to splunklib SDK, it handles proxy, certs etc in this centralized location. All clients should use SplunkRestProxy to do REST call instead of calling splunklib SDK directly in business logic code. __all__ special \u00b6 SplunkRestClient ( Service ) \u00b6 Splunk REST client. __init__ ( self , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes SplunkRestClient. Arguments scheme , host and port are optional in the Splunk environment (when environment variable SPLUNK_HOME is set). In this situation get_splunkd_access_info will be used to set scheme , host and port . In case of using SplunkRestClient outside of Splunk environment - scheme , host and port should be provided. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str Owner of namespace, default is nobody . 'nobody' scheme str The access scheme, default is None. None host str The host name, default is None. None port int The port number, default is None. None context dict Other configurations, it can contain proxy_hostname , proxy_port , proxy_username , proxy_password , then proxy will be accounted and setup, all REST APIs to splunkd will be through the proxy. If context contains key_file , cert_file , then certification will be accounted and setup, all REST APIs to splunkd will use certification. If context contains pool_connections , pool_maxsize , then HTTP connection will be pooled. {} Exceptions: Type Description ValueError if scheme, host or port are invalid. Source code in solnlib/splunk_rest_client.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes SplunkRestClient. Arguments `scheme`, `host` and `port` are optional in the Splunk environment (when environment variable SPLUNK_HOME is set). In this situation `get_splunkd_access_info` will be used to set `scheme`, `host` and `port`. In case of using `SplunkRestClient` outside of Splunk environment - `scheme`, `host` and `port` should be provided. Arguments: session_key: Splunk access token. app: App name of namespace. owner: Owner of namespace, default is `nobody`. scheme: The access scheme, default is None. host: The host name, default is None. port: The port number, default is None. context: Other configurations, it can contain `proxy_hostname`, `proxy_port`, `proxy_username`, `proxy_password`, then proxy will be accounted and setup, all REST APIs to splunkd will be through the proxy. If `context` contains `key_file`, `cert_file`, then certification will be accounted and setup, all REST APIs to splunkd will use certification. If `context` contains `pool_connections`, `pool_maxsize`, then HTTP connection will be pooled. Raises: ValueError: if scheme, host or port are invalid. \"\"\" # Only do splunkd URI discovery in SPLUNK env (SPLUNK_HOME is set). if not all ([ scheme , host , port ]) and os . environ . get ( \"SPLUNK_HOME\" ): scheme , host , port = get_splunkd_access_info () if os . environ . get ( \"SPLUNK_HOME\" ) is None : if not all ([ scheme , host , port ]): raise ValueError ( \"scheme, host, port should be provided outside of Splunk environment\" ) validate_scheme_host_port ( scheme , host , port ) handler = _request_handler ( context ) super () . __init__ ( handler = handler , scheme = scheme , host = host , port = port , token = session_key , app = app , owner = owner , autologin = True , )","title":"splunk_rest_client.py"},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.__all__","text":"","title":"__all__"},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.SplunkRestClient","text":"Splunk REST client.","title":"SplunkRestClient"},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.SplunkRestClient.__init__","text":"Initializes SplunkRestClient. Arguments scheme , host and port are optional in the Splunk environment (when environment variable SPLUNK_HOME is set). In this situation get_splunkd_access_info will be used to set scheme , host and port . In case of using SplunkRestClient outside of Splunk environment - scheme , host and port should be provided. Parameters: Name Type Description Default session_key str Splunk access token. required app str App name of namespace. required owner str Owner of namespace, default is nobody . 'nobody' scheme str The access scheme, default is None. None host str The host name, default is None. None port int The port number, default is None. None context dict Other configurations, it can contain proxy_hostname , proxy_port , proxy_username , proxy_password , then proxy will be accounted and setup, all REST APIs to splunkd will be through the proxy. If context contains key_file , cert_file , then certification will be accounted and setup, all REST APIs to splunkd will use certification. If context contains pool_connections , pool_maxsize , then HTTP connection will be pooled. {} Exceptions: Type Description ValueError if scheme, host or port are invalid. Source code in solnlib/splunk_rest_client.py def __init__ ( self , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes SplunkRestClient. Arguments `scheme`, `host` and `port` are optional in the Splunk environment (when environment variable SPLUNK_HOME is set). In this situation `get_splunkd_access_info` will be used to set `scheme`, `host` and `port`. In case of using `SplunkRestClient` outside of Splunk environment - `scheme`, `host` and `port` should be provided. Arguments: session_key: Splunk access token. app: App name of namespace. owner: Owner of namespace, default is `nobody`. scheme: The access scheme, default is None. host: The host name, default is None. port: The port number, default is None. context: Other configurations, it can contain `proxy_hostname`, `proxy_port`, `proxy_username`, `proxy_password`, then proxy will be accounted and setup, all REST APIs to splunkd will be through the proxy. If `context` contains `key_file`, `cert_file`, then certification will be accounted and setup, all REST APIs to splunkd will use certification. If `context` contains `pool_connections`, `pool_maxsize`, then HTTP connection will be pooled. Raises: ValueError: if scheme, host or port are invalid. \"\"\" # Only do splunkd URI discovery in SPLUNK env (SPLUNK_HOME is set). if not all ([ scheme , host , port ]) and os . environ . get ( \"SPLUNK_HOME\" ): scheme , host , port = get_splunkd_access_info () if os . environ . get ( \"SPLUNK_HOME\" ) is None : if not all ([ scheme , host , port ]): raise ValueError ( \"scheme, host, port should be provided outside of Splunk environment\" ) validate_scheme_host_port ( scheme , host , port ) handler = _request_handler ( context ) super () . __init__ ( handler = handler , scheme = scheme , host = host , port = port , token = session_key , app = app , owner = owner , autologin = True , )","title":"__init__()"},{"location":"splunkenv/","text":"Splunk platform related utilities. ETC_LEAF \u00b6 __all__ special \u00b6 on_shared_storage \u00b6 get_conf_key_value ( conf_name , stanza , key ) \u00b6 Get value of key of stanza in conf_name . Parameters: Name Type Description Default conf_name str Config file. required stanza str Stanza name. required key str Key name. required Returns: Type Description Union[str, List, dict] Config value. Exceptions: Type Description KeyError If stanza or key doesn\u2019t exist. Source code in solnlib/splunkenv.py def get_conf_key_value ( conf_name : str , stanza : str , key : str ) -> Union [ str , List , dict ]: \"\"\"Get value of `key` of `stanza` in `conf_name`. Arguments: conf_name: Config file. stanza: Stanza name. key: Key name. Returns: Config value. Raises: KeyError: If `stanza` or `key` doesn't exist. \"\"\" stanzas = get_conf_stanzas ( conf_name ) return stanzas [ stanza ][ key ] get_conf_stanza ( conf_name , stanza ) \u00b6 Get stanza in conf_name . Parameters: Name Type Description Default conf_name str Config file. required stanza str Stanza name. required Returns: Type Description dict Config stanza. Exceptions: Type Description KeyError If stanza doesn\u2019t exist. Source code in solnlib/splunkenv.py def get_conf_stanza ( conf_name : str , stanza : str ) -> dict : \"\"\"Get `stanza` in `conf_name`. Arguments: conf_name: Config file. stanza: Stanza name. Returns: Config stanza. Raises: KeyError: If stanza doesn't exist. \"\"\" stanzas = get_conf_stanzas ( conf_name ) return stanzas [ stanza ] get_conf_stanzas ( conf_name ) \u00b6 Get stanzas of conf_name Parameters: Name Type Description Default conf_name str Config file. required Returns: Type Description dict Config stanzas. Examples: >>> stanzas = get_conf_stanzas ( 'server' ) >>> return : { 'serverName' : 'testServer' , 'sessionTimeout' : '1h' , ... } Source code in solnlib/splunkenv.py def get_conf_stanzas ( conf_name : str ) -> dict : \"\"\"Get stanzas of `conf_name` Arguments: conf_name: Config file. Returns: Config stanzas. Examples: >>> stanzas = get_conf_stanzas('server') >>> return: {'serverName': 'testServer', 'sessionTimeout': '1h', ...} \"\"\" if conf_name . endswith ( \".conf\" ): conf_name = conf_name [: - 5 ] # TODO: dynamically calculate SPLUNK_HOME btool_cli = [ op . join ( os . environ [ \"SPLUNK_HOME\" ], \"bin\" , \"splunk\" ), \"cmd\" , \"btool\" , conf_name , \"list\" , ] p = subprocess . Popen ( # nosemgrep: python.lang.security.audit.dangerous-subprocess-use.dangerous-subprocess-use btool_cli , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) out , _ = p . communicate () if isinstance ( out , bytes ): out = out . decode () parser = ConfigParser ( ** { \"strict\" : False }) parser . optionxform = str parser . readfp ( StringIO ( out )) out = {} for section in parser . sections (): out [ section ] = { item [ 0 ]: item [ 1 ] for item in parser . items ( section , raw = True )} return out get_splunk_bin () \u00b6 Get absolute path of splunk CLI. Returns: Type Description str Absolute path of splunk CLI. Source code in solnlib/splunkenv.py def get_splunk_bin () -> str : \"\"\"Get absolute path of splunk CLI. Returns: Absolute path of splunk CLI. \"\"\" if os . name == \"nt\" : splunk_bin = \"splunk.exe\" else : splunk_bin = \"splunk\" return make_splunkhome_path (( \"bin\" , splunk_bin )) get_splunk_host_info () \u00b6 Get splunk host info. Returns: Type Description Tuple Tuple of (server_name, host_name). Source code in solnlib/splunkenv.py def get_splunk_host_info () -> Tuple : \"\"\"Get splunk host info. Returns: Tuple of (server_name, host_name). \"\"\" server_name = get_conf_key_value ( \"server\" , \"general\" , \"serverName\" ) host_name = socket . gethostname () return server_name , host_name get_splunkd_access_info () \u00b6 Get splunkd server access info. Returns: Type Description Tuple[str, str, int] Tuple of (scheme, host, port). Source code in solnlib/splunkenv.py def get_splunkd_access_info () -> Tuple [ str , str , int ]: \"\"\"Get splunkd server access info. Returns: Tuple of (scheme, host, port). \"\"\" if get_conf_key_value ( \"server\" , \"sslConfig\" , \"enableSplunkdSSL\" ) == \"true\" : scheme = \"https\" else : scheme = \"http\" host_port = get_conf_key_value ( \"web\" , \"settings\" , \"mgmtHostPort\" ) host_port = host_port . strip () host = host_port . split ( \":\" )[ 0 ] port = int ( host_port . split ( \":\" )[ 1 ]) if \"SPLUNK_BINDIP\" in os . environ : bindip = os . environ [ \"SPLUNK_BINDIP\" ] port_idx = bindip . rfind ( \":\" ) host = bindip [: port_idx ] if port_idx > 0 else bindip return scheme , host , port get_splunkd_uri () \u00b6 Get splunkd uri. Returns: Type Description str Splunkd uri. Source code in solnlib/splunkenv.py def get_splunkd_uri () -> str : \"\"\"Get splunkd uri. Returns: Splunkd uri. \"\"\" if os . environ . get ( \"SPLUNKD_URI\" ): return os . environ [ \"SPLUNKD_URI\" ] scheme , host , port = get_splunkd_access_info () return f \" { scheme } :// { host } : { port } \" make_splunkhome_path ( parts ) \u00b6 Construct absolute path by $SPLUNK_HOME and parts . Concatenate $SPLUNK_HOME and parts to an absolute path. For example, parts is [\u2018etc\u2019, \u2018apps\u2019, \u2018Splunk_TA_test\u2019], the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test. Note: this function assumed SPLUNK_HOME is in environment varialbes. Parameters: Name Type Description Default parts Union[List, Tuple] Path parts. required Returns: Type Description str Absolute path. Exceptions: Type Description ValueError Escape from intended parent directories. Source code in solnlib/splunkenv.py def make_splunkhome_path ( parts : Union [ List , Tuple ]) -> str : \"\"\"Construct absolute path by $SPLUNK_HOME and `parts`. Concatenate $SPLUNK_HOME and `parts` to an absolute path. For example, `parts` is ['etc', 'apps', 'Splunk_TA_test'], the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test. Note: this function assumed SPLUNK_HOME is in environment varialbes. Arguments: parts: Path parts. Returns: Absolute path. Raises: ValueError: Escape from intended parent directories. \"\"\" relpath = os . path . normpath ( os . path . join ( * parts )) basepath = None shared_storage = _get_shared_storage () if shared_storage : for candidate in on_shared_storage : # SPL-100508 On windows if the path is missing the drive letter, # construct fullpath manually and call relpath if os . name == \"nt\" and not _verify_path_prefix ( relpath , candidate ): break if os . path . relpath ( relpath , candidate )[ 0 : 2 ] != \"..\" : basepath = shared_storage break if basepath is None : etc_with_trailing_sep = os . path . join ( ETC_LEAF , \"\" ) if relpath == ETC_LEAF or relpath . startswith ( etc_with_trailing_sep ): # Redirect $SPLUNK_HOME/etc to $SPLUNK_ETC. basepath = _splunk_etc () # Remove leading etc (and path separator, if present). Note: when # emitting $SPLUNK_ETC exactly, with no additional path parts, we # set <relpath> to the empty string. relpath = relpath [ 4 :] else : basepath = _splunk_home () fullpath = os . path . normpath ( os . path . join ( basepath , relpath )) # Check that we haven't escaped from intended parent directories. if os . path . relpath ( fullpath , basepath )[ 0 : 2 ] == \"..\" : raise ValueError ( f 'Illegal escape from parent directory \" { basepath } \": { fullpath } ' ) return fullpath","title":"splunkenv.py"},{"location":"splunkenv/#solnlib.splunkenv.ETC_LEAF","text":"","title":"ETC_LEAF"},{"location":"splunkenv/#solnlib.splunkenv.__all__","text":"","title":"__all__"},{"location":"splunkenv/#solnlib.splunkenv.on_shared_storage","text":"","title":"on_shared_storage"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_key_value","text":"Get value of key of stanza in conf_name . Parameters: Name Type Description Default conf_name str Config file. required stanza str Stanza name. required key str Key name. required Returns: Type Description Union[str, List, dict] Config value. Exceptions: Type Description KeyError If stanza or key doesn\u2019t exist. Source code in solnlib/splunkenv.py def get_conf_key_value ( conf_name : str , stanza : str , key : str ) -> Union [ str , List , dict ]: \"\"\"Get value of `key` of `stanza` in `conf_name`. Arguments: conf_name: Config file. stanza: Stanza name. key: Key name. Returns: Config value. Raises: KeyError: If `stanza` or `key` doesn't exist. \"\"\" stanzas = get_conf_stanzas ( conf_name ) return stanzas [ stanza ][ key ]","title":"get_conf_key_value()"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_stanza","text":"Get stanza in conf_name . Parameters: Name Type Description Default conf_name str Config file. required stanza str Stanza name. required Returns: Type Description dict Config stanza. Exceptions: Type Description KeyError If stanza doesn\u2019t exist. Source code in solnlib/splunkenv.py def get_conf_stanza ( conf_name : str , stanza : str ) -> dict : \"\"\"Get `stanza` in `conf_name`. Arguments: conf_name: Config file. stanza: Stanza name. Returns: Config stanza. Raises: KeyError: If stanza doesn't exist. \"\"\" stanzas = get_conf_stanzas ( conf_name ) return stanzas [ stanza ]","title":"get_conf_stanza()"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_stanzas","text":"Get stanzas of conf_name Parameters: Name Type Description Default conf_name str Config file. required Returns: Type Description dict Config stanzas. Examples: >>> stanzas = get_conf_stanzas ( 'server' ) >>> return : { 'serverName' : 'testServer' , 'sessionTimeout' : '1h' , ... } Source code in solnlib/splunkenv.py def get_conf_stanzas ( conf_name : str ) -> dict : \"\"\"Get stanzas of `conf_name` Arguments: conf_name: Config file. Returns: Config stanzas. Examples: >>> stanzas = get_conf_stanzas('server') >>> return: {'serverName': 'testServer', 'sessionTimeout': '1h', ...} \"\"\" if conf_name . endswith ( \".conf\" ): conf_name = conf_name [: - 5 ] # TODO: dynamically calculate SPLUNK_HOME btool_cli = [ op . join ( os . environ [ \"SPLUNK_HOME\" ], \"bin\" , \"splunk\" ), \"cmd\" , \"btool\" , conf_name , \"list\" , ] p = subprocess . Popen ( # nosemgrep: python.lang.security.audit.dangerous-subprocess-use.dangerous-subprocess-use btool_cli , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) out , _ = p . communicate () if isinstance ( out , bytes ): out = out . decode () parser = ConfigParser ( ** { \"strict\" : False }) parser . optionxform = str parser . readfp ( StringIO ( out )) out = {} for section in parser . sections (): out [ section ] = { item [ 0 ]: item [ 1 ] for item in parser . items ( section , raw = True )} return out","title":"get_conf_stanzas()"},{"location":"splunkenv/#solnlib.splunkenv.get_splunk_bin","text":"Get absolute path of splunk CLI. Returns: Type Description str Absolute path of splunk CLI. Source code in solnlib/splunkenv.py def get_splunk_bin () -> str : \"\"\"Get absolute path of splunk CLI. Returns: Absolute path of splunk CLI. \"\"\" if os . name == \"nt\" : splunk_bin = \"splunk.exe\" else : splunk_bin = \"splunk\" return make_splunkhome_path (( \"bin\" , splunk_bin ))","title":"get_splunk_bin()"},{"location":"splunkenv/#solnlib.splunkenv.get_splunk_host_info","text":"Get splunk host info. Returns: Type Description Tuple Tuple of (server_name, host_name). Source code in solnlib/splunkenv.py def get_splunk_host_info () -> Tuple : \"\"\"Get splunk host info. Returns: Tuple of (server_name, host_name). \"\"\" server_name = get_conf_key_value ( \"server\" , \"general\" , \"serverName\" ) host_name = socket . gethostname () return server_name , host_name","title":"get_splunk_host_info()"},{"location":"splunkenv/#solnlib.splunkenv.get_splunkd_access_info","text":"Get splunkd server access info. Returns: Type Description Tuple[str, str, int] Tuple of (scheme, host, port). Source code in solnlib/splunkenv.py def get_splunkd_access_info () -> Tuple [ str , str , int ]: \"\"\"Get splunkd server access info. Returns: Tuple of (scheme, host, port). \"\"\" if get_conf_key_value ( \"server\" , \"sslConfig\" , \"enableSplunkdSSL\" ) == \"true\" : scheme = \"https\" else : scheme = \"http\" host_port = get_conf_key_value ( \"web\" , \"settings\" , \"mgmtHostPort\" ) host_port = host_port . strip () host = host_port . split ( \":\" )[ 0 ] port = int ( host_port . split ( \":\" )[ 1 ]) if \"SPLUNK_BINDIP\" in os . environ : bindip = os . environ [ \"SPLUNK_BINDIP\" ] port_idx = bindip . rfind ( \":\" ) host = bindip [: port_idx ] if port_idx > 0 else bindip return scheme , host , port","title":"get_splunkd_access_info()"},{"location":"splunkenv/#solnlib.splunkenv.get_splunkd_uri","text":"Get splunkd uri. Returns: Type Description str Splunkd uri. Source code in solnlib/splunkenv.py def get_splunkd_uri () -> str : \"\"\"Get splunkd uri. Returns: Splunkd uri. \"\"\" if os . environ . get ( \"SPLUNKD_URI\" ): return os . environ [ \"SPLUNKD_URI\" ] scheme , host , port = get_splunkd_access_info () return f \" { scheme } :// { host } : { port } \"","title":"get_splunkd_uri()"},{"location":"splunkenv/#solnlib.splunkenv.make_splunkhome_path","text":"Construct absolute path by $SPLUNK_HOME and parts . Concatenate $SPLUNK_HOME and parts to an absolute path. For example, parts is [\u2018etc\u2019, \u2018apps\u2019, \u2018Splunk_TA_test\u2019], the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test. Note: this function assumed SPLUNK_HOME is in environment varialbes. Parameters: Name Type Description Default parts Union[List, Tuple] Path parts. required Returns: Type Description str Absolute path. Exceptions: Type Description ValueError Escape from intended parent directories. Source code in solnlib/splunkenv.py def make_splunkhome_path ( parts : Union [ List , Tuple ]) -> str : \"\"\"Construct absolute path by $SPLUNK_HOME and `parts`. Concatenate $SPLUNK_HOME and `parts` to an absolute path. For example, `parts` is ['etc', 'apps', 'Splunk_TA_test'], the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test. Note: this function assumed SPLUNK_HOME is in environment varialbes. Arguments: parts: Path parts. Returns: Absolute path. Raises: ValueError: Escape from intended parent directories. \"\"\" relpath = os . path . normpath ( os . path . join ( * parts )) basepath = None shared_storage = _get_shared_storage () if shared_storage : for candidate in on_shared_storage : # SPL-100508 On windows if the path is missing the drive letter, # construct fullpath manually and call relpath if os . name == \"nt\" and not _verify_path_prefix ( relpath , candidate ): break if os . path . relpath ( relpath , candidate )[ 0 : 2 ] != \"..\" : basepath = shared_storage break if basepath is None : etc_with_trailing_sep = os . path . join ( ETC_LEAF , \"\" ) if relpath == ETC_LEAF or relpath . startswith ( etc_with_trailing_sep ): # Redirect $SPLUNK_HOME/etc to $SPLUNK_ETC. basepath = _splunk_etc () # Remove leading etc (and path separator, if present). Note: when # emitting $SPLUNK_ETC exactly, with no additional path parts, we # set <relpath> to the empty string. relpath = relpath [ 4 :] else : basepath = _splunk_home () fullpath = os . path . normpath ( os . path . join ( basepath , relpath )) # Check that we haven't escaped from intended parent directories. if os . path . relpath ( fullpath , basepath )[ 0 : 2 ] == \"..\" : raise ValueError ( f 'Illegal escape from parent directory \" { basepath } \": { fullpath } ' ) return fullpath","title":"make_splunkhome_path()"},{"location":"time_parser/","text":"This module provides interfaces to parse and convert timestamp. __all__ special \u00b6 InvalidTimeFormatException ( Exception ) \u00b6 Exception for invalid time format. TimeParser \u00b6 Datetime parser. Use splunkd rest to parse datetime. Examples: >>> from solnlib import time_parser >>> tp = time_parser . TimeParser ( session_key ) >>> tp . to_seconds ( '2011-07-06T21:54:23.000-07:00' ) >>> tp . to_utc ( '2011-07-06T21:54:23.000-07:00' ) >>> tp . to_local ( '2011-07-06T21:54:23.000-07:00' ) URL \u00b6 __init__ ( self , session_key , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes TimeParser. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/time_parser.py def __init__ ( self , session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes TimeParser. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) to_local ( self , time_str ) \u00b6 Parse time_str and convert to local timestamp. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description str Local timestamp in ISO8601 format. Source code in solnlib/time_parser.py @retry ( exceptions = [ binding . HTTPError ]) def to_local ( self , time_str : str ) -> str : \"\"\"Parse `time_str` and convert to local timestamp. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: Local timestamp in ISO8601 format. \"\"\" try : response = self . _rest_client . get ( self . URL , output_mode = \"json\" , time = time_str ) . body . read () except binding . HTTPError as e : if e . status != 400 : raise raise InvalidTimeFormatException ( \"Invalid time format: %s .\" % time_str ) return json . loads ( response )[ time_str ] to_seconds ( self , time_str ) \u00b6 Parse time_str and convert to seconds since epoch. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description float Seconds since epoch. Source code in solnlib/time_parser.py @retry ( exceptions = [ binding . HTTPError ]) def to_seconds ( self , time_str : str ) -> float : \"\"\"Parse `time_str` and convert to seconds since epoch. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: Seconds since epoch. \"\"\" try : response = self . _rest_client . get ( self . URL , output_mode = \"json\" , time = time_str , output_time_format = \" %s \" ) . body . read () except binding . HTTPError as e : if e . status != 400 : raise raise InvalidTimeFormatException ( \"Invalid time format: %s .\" % time_str ) seconds = json . loads ( response )[ time_str ] return float ( seconds ) to_utc ( self , time_str ) \u00b6 Parse time_str and convert to UTC timestamp. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description datetime UTC timestamp. Source code in solnlib/time_parser.py def to_utc ( self , time_str : str ) -> datetime . datetime : \"\"\"Parse `time_str` and convert to UTC timestamp. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: UTC timestamp. \"\"\" return datetime . datetime . utcfromtimestamp ( self . to_seconds ( time_str ))","title":"time_parser.py"},{"location":"time_parser/#solnlib.time_parser.__all__","text":"","title":"__all__"},{"location":"time_parser/#solnlib.time_parser.InvalidTimeFormatException","text":"Exception for invalid time format.","title":"InvalidTimeFormatException"},{"location":"time_parser/#solnlib.time_parser.TimeParser","text":"Datetime parser. Use splunkd rest to parse datetime. Examples: >>> from solnlib import time_parser >>> tp = time_parser . TimeParser ( session_key ) >>> tp . to_seconds ( '2011-07-06T21:54:23.000-07:00' ) >>> tp . to_utc ( '2011-07-06T21:54:23.000-07:00' ) >>> tp . to_local ( '2011-07-06T21:54:23.000-07:00' )","title":"TimeParser"},{"location":"time_parser/#solnlib.time_parser.TimeParser.URL","text":"","title":"URL"},{"location":"time_parser/#solnlib.time_parser.TimeParser.__init__","text":"Initializes TimeParser. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/time_parser.py def __init__ ( self , session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict ): \"\"\"Initializes TimeParser. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. \"\"\" self . _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context )","title":"__init__()"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_local","text":"Parse time_str and convert to local timestamp. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description str Local timestamp in ISO8601 format. Source code in solnlib/time_parser.py @retry ( exceptions = [ binding . HTTPError ]) def to_local ( self , time_str : str ) -> str : \"\"\"Parse `time_str` and convert to local timestamp. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: Local timestamp in ISO8601 format. \"\"\" try : response = self . _rest_client . get ( self . URL , output_mode = \"json\" , time = time_str ) . body . read () except binding . HTTPError as e : if e . status != 400 : raise raise InvalidTimeFormatException ( \"Invalid time format: %s .\" % time_str ) return json . loads ( response )[ time_str ]","title":"to_local()"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_seconds","text":"Parse time_str and convert to seconds since epoch. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description float Seconds since epoch. Source code in solnlib/time_parser.py @retry ( exceptions = [ binding . HTTPError ]) def to_seconds ( self , time_str : str ) -> float : \"\"\"Parse `time_str` and convert to seconds since epoch. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: Seconds since epoch. \"\"\" try : response = self . _rest_client . get ( self . URL , output_mode = \"json\" , time = time_str , output_time_format = \" %s \" ) . body . read () except binding . HTTPError as e : if e . status != 400 : raise raise InvalidTimeFormatException ( \"Invalid time format: %s .\" % time_str ) seconds = json . loads ( response )[ time_str ] return float ( seconds )","title":"to_seconds()"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_utc","text":"Parse time_str and convert to UTC timestamp. Parameters: Name Type Description Default time_str str ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. required Returns: Type Description datetime UTC timestamp. Source code in solnlib/time_parser.py def to_utc ( self , time_str : str ) -> datetime . datetime : \"\"\"Parse `time_str` and convert to UTC timestamp. Arguments: time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00. Returns: UTC timestamp. \"\"\" return datetime . datetime . utcfromtimestamp ( self . to_seconds ( time_str ))","title":"to_utc()"},{"location":"timer_queue/","text":"A simple thread safe timer queue implementation which has O(logn) time complexity. TEARDOWN_SENTINEL \u00b6 __all__ special \u00b6 Timer \u00b6 Timer wraps the callback and timestamp related attributes. __call__ ( self ) special \u00b6 Source code in solnlib/timer_queue.py def __call__ ( self ): self . _callback () __eq__ ( self , other ) special \u00b6 Source code in solnlib/timer_queue.py def __eq__ ( self , other ): return isinstance ( other , Timer ) and ( self . ident == other . ident ) __ge__ ( self , other ) special \u00b6 Source code in solnlib/timer_queue.py def __ge__ ( self , other ): return ( self . when , self . ident ) >= ( other . when , other . ident ) __gt__ ( self , other ) special \u00b6 Source code in solnlib/timer_queue.py def __gt__ ( self , other ): return ( self . when , self . ident ) > ( other . when , other . ident ) __hash__ ( self ) special \u00b6 Source code in solnlib/timer_queue.py def __hash__ ( self ): return hash ( self . ident ) __init__ ( self , callback , when , interval , ident = None ) special \u00b6 Initializes Timer. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed. required ident int (optional) Timer identity. None Source code in solnlib/timer_queue.py def __init__ ( self , callback : Callable , when : int , interval : int , ident : int = None ): \"\"\"Initializes Timer. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed. ident: (optional) Timer identity. \"\"\" self . _callback = callback self . when = when self . interval = interval if ident is not None : self . ident = ident else : with Timer . _lock : self . ident = Timer . _ident + 1 Timer . _ident = Timer . _ident + 1 __le__ ( self , other ) special \u00b6 Source code in solnlib/timer_queue.py def __le__ ( self , other ): return ( self . when , self . ident ) <= ( other . when , other . ident ) __lt__ ( self , other ) special \u00b6 Source code in solnlib/timer_queue.py def __lt__ ( self , other ): return ( self . when , self . ident ) < ( other . when , other . ident ) update_expiration ( self ) \u00b6 Source code in solnlib/timer_queue.py def update_expiration ( self ): self . when += self . interval TimerQueue \u00b6 A simple timer queue implementation. It runs a separate thread to handle timers Note: to effectively use this timer queue, the timer callback should be short, otherwise it will cause other timers\u2019s delay execution. A typical use scenario in production is that the timers are just a simple functions which inject themselvies to a task queue and then they are picked up by a threading/process pool to execute, as shows below: Timers -- enqueue ---> TimerQueue -------- expiration ----------- | | \\ |/ Threading / Process Pool <---- TaskQueue <-- enqueue -- Timers ' callback (nonblocking) Examples: >>> from solnlib import timer_queue >>> tq = timer_queue . TimerQueue () >>> tq . start () >>> t = tq . add_timer ( my_func , time . time (), 10 ) >>> # do other stuff >>> tq . stop () __init__ ( self ) special \u00b6 Source code in solnlib/timer_queue.py def __init__ ( self ): self . _timers = TimerQueueStruct () self . _lock = threading . Lock () self . _wakeup_queue = Queue . Queue () self . _thr = threading . Thread ( target = self . _check_and_execute ) self . _thr . daemon = True self . _started = False add_timer ( self , callback , when , interval , ident = None ) \u00b6 Add timer to the queue. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed required ident int (optional) Timer identity. None Returns: Type Description Timer A timer object which should not be manipulated directly by clients. Used to delete/update the timer. Source code in solnlib/timer_queue.py def add_timer ( self , callback : Callable , when : int , interval : int , ident : int = None ) -> Timer : \"\"\"Add timer to the queue. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed ident: (optional) Timer identity. Returns: A timer object which should not be manipulated directly by clients. Used to delete/update the timer. \"\"\" with self . _lock : timer = self . _timers . add_timer ( callback , when , interval , ident ) self . _wakeup () return timer remove_timer ( self , timer ) \u00b6 Remove timer from the queue. Parameters: Name Type Description Default timer Timer Timer object to remove. required Source code in solnlib/timer_queue.py def remove_timer ( self , timer : Timer ): \"\"\"Remove timer from the queue. Arguments: timer: Timer object to remove. \"\"\" with self . _lock : self . _timers . remove_timer ( timer ) start ( self ) \u00b6 Start the timer queue. Source code in solnlib/timer_queue.py def start ( self ): \"\"\"Start the timer queue.\"\"\" if self . _started : return self . _started = True self . _thr . start () logging . info ( \"TimerQueue started.\" ) stop ( self ) \u00b6 Stop the timer queue. Source code in solnlib/timer_queue.py def stop ( self ): \"\"\"Stop the timer queue.\"\"\" if not self . _started : return self . _started = True self . _wakeup ( TEARDOWN_SENTINEL ) self . _thr . join () TimerQueueStruct \u00b6 The underlying data structure for TimerQueue. __init__ ( self ) special \u00b6 Source code in solnlib/timer_queue.py def __init__ ( self ): self . _timers = sc . SortedSet () self . _cancelling_timers = {} add_timer ( self , callback , when , interval , ident ) \u00b6 Add timer to the data structure. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed required ident int (optional) Timer identity. required Returns: Type Description Timer A timer object which should not be manipulated directly by clients. Used to delete/update the timer. Source code in solnlib/timer_queue.py def add_timer ( self , callback : Callable , when : int , interval : int , ident : int ) -> Timer : \"\"\"Add timer to the data structure. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed ident: (optional) Timer identity. Returns: A timer object which should not be manipulated directly by clients. Used to delete/update the timer. \"\"\" timer = Timer ( callback , when , interval , ident ) self . _timers . add ( timer ) return timer check_and_execute ( self ) \u00b6 Get expired timers and execute callbacks for the timers. Returns: Type Description float Duration of next expired timer. Source code in solnlib/timer_queue.py def check_and_execute ( self ) -> float : \"\"\"Get expired timers and execute callbacks for the timers. Returns: Duration of next expired timer. \"\"\" ( next_expired_time , expired_timers ) = self . get_expired_timers () for timer in expired_timers : try : timer () except Exception : logging . error ( traceback . format_exc ()) self . reset_timers ( expired_timers ) return _calc_sleep_time ( next_expired_time ) get_expired_timers ( self ) \u00b6 Get a list of expired timers. Returns: Type Description Tuple A tuple of Timer , empty list if there is no expired timers. Source code in solnlib/timer_queue.py def get_expired_timers ( self ) -> Tuple : \"\"\"Get a list of expired timers. Returns: A tuple of ``Timer``, empty list if there is no expired timers. \"\"\" next_expired_time = 0 now = time () expired_timers = [] for timer in self . _timers : if timer . when <= now : expired_timers . append ( timer ) if expired_timers : del self . _timers [: len ( expired_timers )] if self . _timers : next_expired_time = self . _timers [ 0 ] . when return next_expired_time , expired_timers remove_timer ( self , timer ) \u00b6 Remove timer from data structure. Parameters: Name Type Description Default timer Timer Timer object which is returned by TimerQueueStruct.add_timer . required Source code in solnlib/timer_queue.py def remove_timer ( self , timer : Timer ): \"\"\"Remove timer from data structure. Arguments: timer: Timer object which is returned by ``TimerQueueStruct.add_timer``. \"\"\" try : self . _timers . remove ( timer ) except ValueError : logging . info ( \"Timer= %s is not in queue, move it to cancelling \" \"list\" , timer . ident ) else : self . _cancelling_timers [ timer . ident ] = timer reset_timers ( self , expired_timers ) \u00b6 Re-add the expired periodical timers to data structure for next round scheduling. Parameters: Name Type Description Default expired_timers List[solnlib.timer_queue.Timer] List of expired timers. required Returns: Type Description bool True if there are timers added, False otherwise. Source code in solnlib/timer_queue.py def reset_timers ( self , expired_timers : List [ Timer ]) -> bool : \"\"\"Re-add the expired periodical timers to data structure for next round scheduling. Arguments: expired_timers: List of expired timers. Returns: True if there are timers added, False otherwise. \"\"\" has_new_timer = False cancelling_timers = self . _cancelling_timers for timer in expired_timers : if timer . ident in cancelling_timers : continue elif timer . interval : # Repeated timer timer . update_expiration () self . _timers . add ( timer ) has_new_timer = True cancelling_timers . clear () return has_new_timer","title":"timer_queue.py"},{"location":"timer_queue/#solnlib.timer_queue.TEARDOWN_SENTINEL","text":"","title":"TEARDOWN_SENTINEL"},{"location":"timer_queue/#solnlib.timer_queue.__all__","text":"","title":"__all__"},{"location":"timer_queue/#solnlib.timer_queue.Timer","text":"Timer wraps the callback and timestamp related attributes.","title":"Timer"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__call__","text":"Source code in solnlib/timer_queue.py def __call__ ( self ): self . _callback ()","title":"__call__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__eq__","text":"Source code in solnlib/timer_queue.py def __eq__ ( self , other ): return isinstance ( other , Timer ) and ( self . ident == other . ident )","title":"__eq__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__ge__","text":"Source code in solnlib/timer_queue.py def __ge__ ( self , other ): return ( self . when , self . ident ) >= ( other . when , other . ident )","title":"__ge__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__gt__","text":"Source code in solnlib/timer_queue.py def __gt__ ( self , other ): return ( self . when , self . ident ) > ( other . when , other . ident )","title":"__gt__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__hash__","text":"Source code in solnlib/timer_queue.py def __hash__ ( self ): return hash ( self . ident )","title":"__hash__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__init__","text":"Initializes Timer. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed. required ident int (optional) Timer identity. None Source code in solnlib/timer_queue.py def __init__ ( self , callback : Callable , when : int , interval : int , ident : int = None ): \"\"\"Initializes Timer. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed. ident: (optional) Timer identity. \"\"\" self . _callback = callback self . when = when self . interval = interval if ident is not None : self . ident = ident else : with Timer . _lock : self . ident = Timer . _ident + 1 Timer . _ident = Timer . _ident + 1","title":"__init__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__le__","text":"Source code in solnlib/timer_queue.py def __le__ ( self , other ): return ( self . when , self . ident ) <= ( other . when , other . ident )","title":"__le__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__lt__","text":"Source code in solnlib/timer_queue.py def __lt__ ( self , other ): return ( self . when , self . ident ) < ( other . when , other . ident )","title":"__lt__()"},{"location":"timer_queue/#solnlib.timer_queue.Timer.update_expiration","text":"Source code in solnlib/timer_queue.py def update_expiration ( self ): self . when += self . interval","title":"update_expiration()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue","text":"A simple timer queue implementation. It runs a separate thread to handle timers Note: to effectively use this timer queue, the timer callback should be short, otherwise it will cause other timers\u2019s delay execution. A typical use scenario in production is that the timers are just a simple functions which inject themselvies to a task queue and then they are picked up by a threading/process pool to execute, as shows below: Timers -- enqueue ---> TimerQueue -------- expiration ----------- | | \\ |/ Threading / Process Pool <---- TaskQueue <-- enqueue -- Timers ' callback (nonblocking) Examples: >>> from solnlib import timer_queue >>> tq = timer_queue . TimerQueue () >>> tq . start () >>> t = tq . add_timer ( my_func , time . time (), 10 ) >>> # do other stuff >>> tq . stop ()","title":"TimerQueue"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.__init__","text":"Source code in solnlib/timer_queue.py def __init__ ( self ): self . _timers = TimerQueueStruct () self . _lock = threading . Lock () self . _wakeup_queue = Queue . Queue () self . _thr = threading . Thread ( target = self . _check_and_execute ) self . _thr . daemon = True self . _started = False","title":"__init__()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.add_timer","text":"Add timer to the queue. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed required ident int (optional) Timer identity. None Returns: Type Description Timer A timer object which should not be manipulated directly by clients. Used to delete/update the timer. Source code in solnlib/timer_queue.py def add_timer ( self , callback : Callable , when : int , interval : int , ident : int = None ) -> Timer : \"\"\"Add timer to the queue. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed ident: (optional) Timer identity. Returns: A timer object which should not be manipulated directly by clients. Used to delete/update the timer. \"\"\" with self . _lock : timer = self . _timers . add_timer ( callback , when , interval , ident ) self . _wakeup () return timer","title":"add_timer()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.remove_timer","text":"Remove timer from the queue. Parameters: Name Type Description Default timer Timer Timer object to remove. required Source code in solnlib/timer_queue.py def remove_timer ( self , timer : Timer ): \"\"\"Remove timer from the queue. Arguments: timer: Timer object to remove. \"\"\" with self . _lock : self . _timers . remove_timer ( timer )","title":"remove_timer()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.start","text":"Start the timer queue. Source code in solnlib/timer_queue.py def start ( self ): \"\"\"Start the timer queue.\"\"\" if self . _started : return self . _started = True self . _thr . start () logging . info ( \"TimerQueue started.\" )","title":"start()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.stop","text":"Stop the timer queue. Source code in solnlib/timer_queue.py def stop ( self ): \"\"\"Stop the timer queue.\"\"\" if not self . _started : return self . _started = True self . _wakeup ( TEARDOWN_SENTINEL ) self . _thr . join ()","title":"stop()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct","text":"The underlying data structure for TimerQueue.","title":"TimerQueueStruct"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.__init__","text":"Source code in solnlib/timer_queue.py def __init__ ( self ): self . _timers = sc . SortedSet () self . _cancelling_timers = {}","title":"__init__()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.add_timer","text":"Add timer to the data structure. Parameters: Name Type Description Default callback Callable Arbitrary callable object. required when int The first expiration time, seconds since epoch. required interval int Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed required ident int (optional) Timer identity. required Returns: Type Description Timer A timer object which should not be manipulated directly by clients. Used to delete/update the timer. Source code in solnlib/timer_queue.py def add_timer ( self , callback : Callable , when : int , interval : int , ident : int ) -> Timer : \"\"\"Add timer to the data structure. Arguments: callback: Arbitrary callable object. when: The first expiration time, seconds since epoch. interval: Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed ident: (optional) Timer identity. Returns: A timer object which should not be manipulated directly by clients. Used to delete/update the timer. \"\"\" timer = Timer ( callback , when , interval , ident ) self . _timers . add ( timer ) return timer","title":"add_timer()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.check_and_execute","text":"Get expired timers and execute callbacks for the timers. Returns: Type Description float Duration of next expired timer. Source code in solnlib/timer_queue.py def check_and_execute ( self ) -> float : \"\"\"Get expired timers and execute callbacks for the timers. Returns: Duration of next expired timer. \"\"\" ( next_expired_time , expired_timers ) = self . get_expired_timers () for timer in expired_timers : try : timer () except Exception : logging . error ( traceback . format_exc ()) self . reset_timers ( expired_timers ) return _calc_sleep_time ( next_expired_time )","title":"check_and_execute()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.get_expired_timers","text":"Get a list of expired timers. Returns: Type Description Tuple A tuple of Timer , empty list if there is no expired timers. Source code in solnlib/timer_queue.py def get_expired_timers ( self ) -> Tuple : \"\"\"Get a list of expired timers. Returns: A tuple of ``Timer``, empty list if there is no expired timers. \"\"\" next_expired_time = 0 now = time () expired_timers = [] for timer in self . _timers : if timer . when <= now : expired_timers . append ( timer ) if expired_timers : del self . _timers [: len ( expired_timers )] if self . _timers : next_expired_time = self . _timers [ 0 ] . when return next_expired_time , expired_timers","title":"get_expired_timers()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.remove_timer","text":"Remove timer from data structure. Parameters: Name Type Description Default timer Timer Timer object which is returned by TimerQueueStruct.add_timer . required Source code in solnlib/timer_queue.py def remove_timer ( self , timer : Timer ): \"\"\"Remove timer from data structure. Arguments: timer: Timer object which is returned by ``TimerQueueStruct.add_timer``. \"\"\" try : self . _timers . remove ( timer ) except ValueError : logging . info ( \"Timer= %s is not in queue, move it to cancelling \" \"list\" , timer . ident ) else : self . _cancelling_timers [ timer . ident ] = timer","title":"remove_timer()"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.reset_timers","text":"Re-add the expired periodical timers to data structure for next round scheduling. Parameters: Name Type Description Default expired_timers List[solnlib.timer_queue.Timer] List of expired timers. required Returns: Type Description bool True if there are timers added, False otherwise. Source code in solnlib/timer_queue.py def reset_timers ( self , expired_timers : List [ Timer ]) -> bool : \"\"\"Re-add the expired periodical timers to data structure for next round scheduling. Arguments: expired_timers: List of expired timers. Returns: True if there are timers added, False otherwise. \"\"\" has_new_timer = False cancelling_timers = self . _cancelling_timers for timer in expired_timers : if timer . ident in cancelling_timers : continue elif timer . interval : # Repeated timer timer . update_expiration () self . _timers . add ( timer ) has_new_timer = True cancelling_timers . clear () return has_new_timer","title":"reset_timers()"},{"location":"user_access/","text":"Splunk user access control related utilities. __all__ special \u00b6 AppCapabilityManager \u00b6 App capability manager. Examples: >>> from solnlib import user_access >>> acm = user_access . AppCapabilityManager ( 'test_collection' , session_key , 'Splunk_TA_test' ) >>> acm . register_capabilities ( ... ) >>> acm . unregister_capabilities ( ... ) __init__ ( self , collection_name , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes AppCapabilityManager. Parameters: Name Type Description Default collection_name str Collection name to store capabilities. required session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description AppCapabilityManagerException If init AppCapabilityManager failed. Source code in solnlib/user_access.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes AppCapabilityManager. Arguments: collection_name: Collection name to store capabilities. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: AppCapabilityManagerException: If init AppCapabilityManager failed. \"\"\" self . _app = app collection_name = f \" { app } _ { collection_name } \" try : self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , None , ** context , ) except KeyError : raise AppCapabilityManagerException ( f \"Get app capabilities collection: { collection_name } failed.\" ) capabilities_are_registered ( self ) \u00b6 Check if app capabilities are registered. Returns: Type Description bool True if app capabilities are registered else False. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def capabilities_are_registered ( self ) -> bool : \"\"\"Check if app capabilities are registered. Returns: True if app capabilities are registered else False. \"\"\" try : self . _collection_data . query_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise return False return True get_capabilities ( self ) \u00b6 Get app capabilities. Returns: Type Description dict App capabilities. Exceptions: Type Description AppCapabilityNotExistException If app capabilities are not registered. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_capabilities ( self ) -> dict : \"\"\"Get app capabilities. Returns: App capabilities. Raises: AppCapabilityNotExistException: If app capabilities are not registered. \"\"\" try : record = self . _collection_data . query_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise raise AppCapabilityNotExistException ( \"App capabilities for %s have not been registered.\" % self . _app ) return record [ \"capabilities\" ] register_capabilities ( self , capabilities ) \u00b6 Register app capabilities. Parameters: Name Type Description Default capabilities dict App capabilities, example: { \u2018object_type1\u2019: { \u2018read\u2019: \u2018read_app_object_type1\u2019, \u2018write\u2019: \u2018write_app_object_type1\u2019, \u2018delete\u2019: \u2018delete_app_object_type1\u2019}, \u2018object_type2\u2019: { \u2018read\u2019: \u2018read_app_object_type2\u2019, \u2018write\u2019: \u2018write_app_object_type2\u2019, \u2018delete\u2019: \u2018delete_app_object_type2\u2019 }, \u2026 } required Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def register_capabilities ( self , capabilities : dict ): \"\"\"Register app capabilities. Arguments: capabilities: App capabilities, example: { 'object_type1': { 'read': 'read_app_object_type1', 'write': 'write_app_object_type1', 'delete': 'delete_app_object_type1'}, 'object_type2': { 'read': 'read_app_object_type2', 'write': 'write_app_object_type2', 'delete': 'delete_app_object_type2' }, ... } \"\"\" record = { \"_key\" : self . _app , \"capabilities\" : capabilities } self . _collection_data . batch_save ( record ) unregister_capabilities ( self ) \u00b6 Unregister app capabilities. Exceptions: Type Description AppCapabilityNotExistException If app capabilities are not registered. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def unregister_capabilities ( self ): \"\"\"Unregister app capabilities. Raises: AppCapabilityNotExistException: If app capabilities are not registered. \"\"\" try : self . _collection_data . delete_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise raise AppCapabilityNotExistException ( \"App capabilities for %s have not been registered.\" % self . _app ) AppCapabilityManagerException ( Exception ) \u00b6 Exception for AppCapabilityManager. AppCapabilityNotExistException ( Exception ) \u00b6 Exception for the situation when AppCapability does not exist for a specific app. InvalidSessionKeyException ( Exception ) \u00b6 Exception when Splunk session key is invalid. ObjectACL \u00b6 Object ACL record. Examples: >>> from solnlib import user_access >>> obj_acl = user_access . ObjectACL ( >>> 'test_collection' , >>> '9defa6f510d711e6be16a45e60e34295' , >>> 'test_object' , >>> 'Splunk_TA_test' , >>> 'admin' , >>> { 'read' : [ '*' ], 'write' : [ 'admin' ], 'delete' : [ 'admin' ]}, >>> False ) OBJ_APP_KEY \u00b6 OBJ_COLLECTION_KEY \u00b6 OBJ_ID_KEY \u00b6 OBJ_OWNER_KEY \u00b6 OBJ_PERMS_ALLOW_ALL \u00b6 OBJ_PERMS_DELETE_KEY \u00b6 OBJ_PERMS_KEY \u00b6 OBJ_PERMS_READ_KEY \u00b6 OBJ_PERMS_WRITE_KEY \u00b6 OBJ_SHARED_BY_INCLUSION_KEY \u00b6 OBJ_TYPE_KEY \u00b6 obj_perms property writable \u00b6 record : dict property readonly \u00b6 Get object acl record. Returns: Object acl record, like: { '_key': 'test_collection-1234', 'obj_collection': 'test_collection', 'obj_id': '1234', 'obj_type': 'test_object', 'obj_app': 'Splunk_TA_test', 'obj_owner': 'admin', 'obj_perms': {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}, 'obj_shared_by_inclusion': True } __init__ ( self , obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion ) special \u00b6 Initializes ObjectACL. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: {\u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019]}. required obj_shared_by_inclusion bool Flag of object is shared by inclusion. required Source code in solnlib/user_access.py def __init__ ( self , obj_collection : str , obj_id : str , obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool , ): \"\"\"Initializes ObjectACL. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}. obj_shared_by_inclusion: Flag of object is shared by inclusion. \"\"\" self . obj_collection = obj_collection self . obj_id = obj_id self . obj_type = obj_type self . obj_app = obj_app self . obj_owner = obj_owner self . _check_perms ( obj_perms ) self . _obj_perms = obj_perms self . obj_shared_by_inclusion = obj_shared_by_inclusion __str__ ( self ) special \u00b6 Source code in solnlib/user_access.py def __str__ ( self ): return json . dumps ( self . record ) generate_key ( obj_collection , obj_id ) staticmethod \u00b6 Generate object acl record key. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Returns: Type Description str Object acl record key. Source code in solnlib/user_access.py @staticmethod def generate_key ( obj_collection : str , obj_id : str ) -> str : \"\"\"Generate object acl record key. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Returns: Object acl record key. \"\"\" return \" {obj_collection} _ {obj_id} \" . format ( obj_collection = obj_collection , obj_id = obj_id ) merge ( self , obj_acl ) \u00b6 Merge current object perms with perms of obj_acl . Parameters: Name Type Description Default obj_acl ObjectACL Object acl to merge. required Source code in solnlib/user_access.py def merge ( self , obj_acl : \"ObjectACL\" ): \"\"\"Merge current object perms with perms of `obj_acl`. Arguments: obj_acl: Object acl to merge. \"\"\" for perm_key in self . _obj_perms : self . _obj_perms [ perm_key ] = list ( set . union ( set ( self . _obj_perms [ perm_key ]), set ( obj_acl . _obj_perms [ perm_key ]) ) ) if self . OBJ_PERMS_ALLOW_ALL in self . _obj_perms [ perm_key ]: self . _obj_perms [ perm_key ] = [ self . OBJ_PERMS_ALLOW_ALL ] parse ( obj_acl_record ) staticmethod \u00b6 Parse object acl record and construct a new ObjectACL object from it. Parameters: Name Type Description Default obj_acl_record dict Object acl record. required Returns: Type Description ObjectACL New ObjectACL object. Source code in solnlib/user_access.py @staticmethod def parse ( obj_acl_record : dict ) -> \"ObjectACL\" : \"\"\"Parse object acl record and construct a new `ObjectACL` object from it. Arguments: obj_acl_record: Object acl record. Returns: New `ObjectACL` object. \"\"\" return ObjectACL ( obj_acl_record [ ObjectACL . OBJ_COLLECTION_KEY ], obj_acl_record [ ObjectACL . OBJ_ID_KEY ], obj_acl_record [ ObjectACL . OBJ_TYPE_KEY ], obj_acl_record [ ObjectACL . OBJ_APP_KEY ], obj_acl_record [ ObjectACL . OBJ_OWNER_KEY ], obj_acl_record [ ObjectACL . OBJ_PERMS_KEY ], obj_acl_record [ ObjectACL . OBJ_SHARED_BY_INCLUSION_KEY ], ) ObjectACLException ( Exception ) \u00b6 ObjectACLManager \u00b6 Object ACL manager. Examples: >>> from solnlib import user_access >>> oaclm = user_access . ObjectACLManager ( session_key , 'Splunk_TA_test' ) __init__ ( self , collection_name , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes ObjectACLManager. Parameters: Name Type Description Default collection_name str Collection name to store object ACL info. required session_key str Splunk access token. required app str App name of namespace. required owner Optional[str] (optional) Owner of namespace, default is nobody . 'nobody' scheme Optional[str] (optional) The access scheme, default is None. None host Optional[str] (optional) The host name, default is None. None port Optional[int] (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description ObjectACLManagerException If init ObjectACLManager failed. Source code in solnlib/user_access.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : Optional [ str ] = \"nobody\" , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : dict , ): \"\"\"Initializes ObjectACLManager. Arguments: collection_name: Collection name to store object ACL info. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: ObjectACLManagerException: If init ObjectACLManager failed. \"\"\" collection_name = \" {app} _ {collection_name} \" . format ( app = app , collection_name = collection_name ) try : self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , None , ** context , ) except KeyError : raise ObjectACLManagerException ( f \"Get object acl collection: { collection_name } fail.\" ) delete_acl ( self , obj_collection , obj_id ) \u00b6 Delete acl info. Query object acl info with parameter of the combination of obj_collection and obj_ids from KVStore and delete it. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Exceptions: Type Description ObjectACLNotExistException If object ACL info does not exist. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete_acl ( self , obj_collection : str , obj_id : str ): \"\"\"Delete acl info. Query object acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and delete it. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Raises: ObjectACLNotExistException: If object ACL info does not exist. \"\"\" key = ObjectACL . generate_key ( obj_collection , obj_id ) try : self . _collection_data . delete_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : raise raise ObjectACLNotExistException ( \"Object ACL info of {} _ {} does not exist.\" . format ( obj_collection , obj_id ) ) delete_acls ( self , obj_collection , obj_ids ) \u00b6 Batch delete acl info. Query objects acl info with parameter of the combination of obj_collection and obj_ids from KVStore and delete them. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete_acls ( self , obj_collection : str , obj_ids : List [ str ]): \"\"\"Batch delete acl info. Query objects acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and delete them. Arguments: obj_collection: Collection where object currently stored. obj_ids: IDs of objects. \"\"\" query = json . dumps ( { \"$or\" : [ { \"_key\" : ObjectACL . generate_key ( obj_collection , obj_id )} for obj_id in obj_ids ] } ) self . _collection_data . delete ( query = query ) get_accessible_object_ids ( self , user , operation , obj_collection , obj_ids ) \u00b6 Get accessible IDs of objects from obj_acls . Parameters: Name Type Description Default user str User name of current operation . required operation str User operation, possible option: (read/write/delete). required obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Returns: Type Description List[str] List of IDs of accessible objects. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_accessible_object_ids ( self , user : str , operation : str , obj_collection : str , obj_ids : List [ str ] ) -> List [ str ]: \"\"\"Get accessible IDs of objects from `obj_acls`. Arguments: user: User name of current `operation`. operation: User operation, possible option: (read/write/delete). obj_collection: Collection where object currently stored. obj_ids: IDs of objects. Returns: List of IDs of accessible objects. \"\"\" obj_acls = self . get_acls ( obj_collection , obj_ids ) accessible_obj_ids = [] for obj_acl in obj_acls : perms = obj_acl . obj_perms [ operation ] if ObjectACL . OBJ_PERMS_ALLOW_ALL in perms or user in perms : accessible_obj_ids . append ( obj_acl . obj_id ) return accessible_obj_ids get_acl ( self , obj_collection , obj_id ) \u00b6 Get acl info. Query object acl info with parameter of the combination of obj_collection and obj_id from self.collection_name and return it. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Returns: Type Description ObjectACL Object acl info if success else None. Exceptions: Type Description ObjectACLNotExistException If object ACL info does not exist. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_acl ( self , obj_collection : str , obj_id : str ) -> \"ObjectACL\" : \"\"\"Get acl info. Query object acl info with parameter of the combination of `obj_collection` and `obj_id` from `self.collection_name` and return it. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Returns: Object acl info if success else None. Raises: ObjectACLNotExistException: If object ACL info does not exist. \"\"\" key = ObjectACL . generate_key ( obj_collection , obj_id ) try : obj_acl = self . _collection_data . query_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : raise raise ObjectACLNotExistException ( \"Object ACL info of {} _ {} does not exist.\" . format ( obj_collection , obj_id ) ) return ObjectACL . parse ( obj_acl ) get_acls ( self , obj_collection , obj_ids ) \u00b6 Batch get acl info. Query objects acl info with parameter of the combination of obj_collection and obj_ids from KVStore and return them. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Returns: Type Description List[solnlib.user_access.ObjectACL] List of ObjectACL instances. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_acls ( self , obj_collection : str , obj_ids : List [ str ]) -> List [ ObjectACL ]: \"\"\"Batch get acl info. Query objects acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and return them. Arguments: obj_collection: Collection where object currently stored. obj_ids: IDs of objects. Returns: List of `ObjectACL` instances. \"\"\" query = json . dumps ( { \"$or\" : [ { \"_key\" : ObjectACL . generate_key ( obj_collection , obj_id )} for obj_id in obj_ids ] } ) obj_acls = self . _collection_data . query ( query = query ) return [ ObjectACL . parse ( obj_acl ) for obj_acl in obj_acls ] update_acl ( self , obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion = True , replace_existing = True ) \u00b6 Update acl info of object. Construct a new object acl info first, if replace_existing is True then replace existing acl info else merge new object acl info with the old one and replace the old acl info with merged acl info. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: { \u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019] }. required obj_shared_by_inclusion bool (optional) Flag of object is shared by inclusion, default is True. True replace_existing bool (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. True Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update_acl ( self , obj_collection : str , obj_id : str , obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool = True , replace_existing : bool = True , ): \"\"\"Update acl info of object. Construct a new object acl info first, if `replace_existing` is True then replace existing acl info else merge new object acl info with the old one and replace the old acl info with merged acl info. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: { 'read': ['*'], 'write': ['admin'], 'delete': ['admin'] }. obj_shared_by_inclusion: (optional) Flag of object is shared by inclusion, default is True. replace_existing: (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. \"\"\" obj_acl = ObjectACL ( obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion , ) if not replace_existing : try : old_obj_acl = self . get_acl ( obj_collection , obj_id ) except ObjectACLNotExistException : old_obj_acl = None if old_obj_acl : obj_acl . merge ( old_obj_acl ) self . _collection_data . batch_save ( obj_acl . record ) update_acls ( self , obj_collection , obj_ids , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion = True , replace_existing = True ) \u00b6 Batch update object acl info to all provided obj_ids . Parameters: Name Type Description Default obj_collection str Collection where objects currently stored. required obj_ids List[str] IDs list of objects. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: { \u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019] }. required obj_shared_by_inclusion bool (optional) Flag of object is shared by inclusion, default is True. True replace_existing bool (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. True Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update_acls ( self , obj_collection : str , obj_ids : List [ str ], obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool = True , replace_existing : bool = True , ): \"\"\"Batch update object acl info to all provided `obj_ids`. Arguments: obj_collection: Collection where objects currently stored. obj_ids: IDs list of objects. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: { 'read': ['*'], 'write': ['admin'], 'delete': ['admin'] }. obj_shared_by_inclusion: (optional) Flag of object is shared by inclusion, default is True. replace_existing: (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. \"\"\" obj_acl_records = [] for obj_id in obj_ids : obj_acl = ObjectACL ( obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion , ) if not replace_existing : try : old_obj_acl = self . get_acl ( obj_collection , obj_id ) except ObjectACLNotExistException : old_obj_acl = None if old_obj_acl : obj_acl . merge ( old_obj_acl ) obj_acl_records . append ( obj_acl . record ) self . _collection_data . batch_save ( * obj_acl_records ) ObjectACLManagerException ( Exception ) \u00b6 Exception for ObjectACLManager. ObjectACLNotExistException ( Exception ) \u00b6 Exception for the situation when ACL does not exist. UserAccessException ( Exception ) \u00b6 Exception for the situation when there is user access exception. UserNotExistException ( Exception ) \u00b6 Exception when user does not exist. check_user_access ( session_key , capabilities , obj_type , operation , scheme = None , host = None , port = None , ** context ) \u00b6 User access checker. It will fetch user capabilities from given session_key and check if the capability extracted from capabilities , obj_type and operation is contained, if user capabilities include the extracted capability user access is ok else fail. Parameters: Name Type Description Default session_key str Splunk access token. required capabilities dict App capabilities, example: { \u2018object_type1\u2019: { \u2018read\u2019: \u2018read_app_object_type1\u2019, \u2018write\u2019: \u2018write_app_object_type1\u2019, \u2018delete\u2019: \u2018delete_app_object_type1\u2019}, \u2018object_type2\u2019: { \u2018read\u2019: \u2018read_app_object_type2\u2019, \u2018write\u2019: \u2018write_app_object_type2\u2019, \u2018delete\u2019: \u2018delete_app_object_type2\u2019 }, \u2026 } required obj_type str Object type. required operation str User operation, possible option: (read/write/delete). required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description UserAccessException If user access permission is denied. Examples: >>> from solnlib.user_access import check_user_access >>> def fun (): >>> check_user_access ( >>> session_key , capabilities , 'test_object' , 'read' ) >>> ... Source code in solnlib/user_access.py def check_user_access ( session_key : str , capabilities : dict , obj_type : str , operation : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"User access checker. It will fetch user capabilities from given `session_key` and check if the capability extracted from `capabilities`, `obj_type` and `operation` is contained, if user capabilities include the extracted capability user access is ok else fail. Arguments: session_key: Splunk access token. capabilities: App capabilities, example: { 'object_type1': { 'read': 'read_app_object_type1', 'write': 'write_app_object_type1', 'delete': 'delete_app_object_type1'}, 'object_type2': { 'read': 'read_app_object_type2', 'write': 'write_app_object_type2', 'delete': 'delete_app_object_type2' }, ... } obj_type: Object type. operation: User operation, possible option: (read/write/delete). scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: UserAccessException: If user access permission is denied. Examples: >>> from solnlib.user_access import check_user_access >>> def fun(): >>> check_user_access( >>> session_key, capabilities, 'test_object', 'read') >>> ... \"\"\" username = get_current_username ( session_key , scheme = scheme , host = host , port = port , ** context ) capability = capabilities [ obj_type ][ operation ] if not user_is_capable ( session_key , username , capability , scheme = scheme , host = host , port = port , ** context , ): raise UserAccessException ( \"Permission denied, %s does not have the capability: %s .\" % ( username , capability ) ) get_current_username ( session_key , scheme = None , host = None , port = None , ** context ) \u00b6 Get current user name from session_key . Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description str Current user name. Exceptions: Type Description InvalidSessionKeyException If session_key is invalid. Examples: >>> from solnlib import user_access >>> user_name = user_access . get_current_username ( session_key ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_current_username ( session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> str : \"\"\"Get current user name from `session_key`. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: Current user name. Raises: InvalidSessionKeyException: If `session_key` is invalid. Examples: >>> from solnlib import user_access >>> user_name = user_access.get_current_username(session_key) \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) try : response = _rest_client . get ( \"/services/authentication/current-context\" , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 401 : raise raise InvalidSessionKeyException ( \"Invalid session key.\" ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"username\" ] get_user_capabilities ( session_key , username , scheme = None , host = None , port = None , ** context ) \u00b6 Get user capabilities. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description List[dict] User capabilities. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> user_capabilities = user_access . get_user_capabilities ( >>> session_key , 'test_user' ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_user_capabilities ( session_key : str , username : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> List [ dict ]: \"\"\"Get user capabilities. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: User capabilities. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> user_capabilities = user_access.get_user_capabilities( >>> session_key, 'test_user') \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) url = f \"/services/authentication/users/ { username } \" try : response = _rest_client . get ( url , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise UserNotExistException ( \"User: %s does not exist.\" % username ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"capabilities\" ] get_user_roles ( session_key , username , scheme = None , host = None , port = None , ** context ) \u00b6 Get user roles. Parameters: Name Type Description Default session_key str Splunk access token. required username str (optional) User name of roles to get. required scheme (optional) The access scheme, default is None. None host (optional) The host name, default is None. None port (optional) The port number, default is None. None context Other configurations for Splunk rest client. {} Returns: Type Description List User roles. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> user_roles = user_access . get_user_roles ( session_key , 'test_user' ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_user_roles ( session_key : str , username : str , scheme = None , host = None , port = None , ** context ) -> List : \"\"\"Get user roles. Arguments: session_key: Splunk access token. username: (optional) User name of roles to get. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: User roles. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> user_roles = user_access.get_user_roles(session_key, 'test_user') \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) url = f \"/services/authentication/users/ { username } \" try : response = _rest_client . get ( url , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise UserNotExistException ( \"User: %s does not exist.\" % username ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"roles\" ] user_is_capable ( session_key , username , capability , scheme = None , host = None , port = None , ** context ) \u00b6 Check if user is capable for given capability . Parameters: Name Type Description Default session_key str Splunk access token. required username str (optional) User name of roles to get. required capability str The capability we wish to check for. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description bool True if user is capable else False. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> is_capable = user_access . user_is_capable ( >>> session_key , 'test_user' , 'object_read_capability' ) Source code in solnlib/user_access.py def user_is_capable ( session_key : str , username : str , capability : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> bool : \"\"\"Check if user is capable for given `capability`. Arguments: session_key: Splunk access token. username: (optional) User name of roles to get. capability: The capability we wish to check for. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: True if user is capable else False. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> is_capable = user_access.user_is_capable( >>> session_key, 'test_user', 'object_read_capability') \"\"\" capabilities = get_user_capabilities ( session_key , username , scheme = scheme , host = host , port = port , ** context ) return capability in capabilities","title":"user_access.py"},{"location":"user_access/#solnlib.user_access.__all__","text":"","title":"__all__"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager","text":"App capability manager. Examples: >>> from solnlib import user_access >>> acm = user_access . AppCapabilityManager ( 'test_collection' , session_key , 'Splunk_TA_test' ) >>> acm . register_capabilities ( ... ) >>> acm . unregister_capabilities ( ... )","title":"AppCapabilityManager"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.__init__","text":"Initializes AppCapabilityManager. Parameters: Name Type Description Default collection_name str Collection name to store capabilities. required session_key str Splunk access token. required app str App name of namespace. required owner str (optional) Owner of namespace, default is nobody . 'nobody' scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description AppCapabilityManagerException If init AppCapabilityManager failed. Source code in solnlib/user_access.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : str = \"nobody\" , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"Initializes AppCapabilityManager. Arguments: collection_name: Collection name to store capabilities. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: AppCapabilityManagerException: If init AppCapabilityManager failed. \"\"\" self . _app = app collection_name = f \" { app } _ { collection_name } \" try : self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , None , ** context , ) except KeyError : raise AppCapabilityManagerException ( f \"Get app capabilities collection: { collection_name } failed.\" )","title":"__init__()"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.capabilities_are_registered","text":"Check if app capabilities are registered. Returns: Type Description bool True if app capabilities are registered else False. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def capabilities_are_registered ( self ) -> bool : \"\"\"Check if app capabilities are registered. Returns: True if app capabilities are registered else False. \"\"\" try : self . _collection_data . query_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise return False return True","title":"capabilities_are_registered()"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.get_capabilities","text":"Get app capabilities. Returns: Type Description dict App capabilities. Exceptions: Type Description AppCapabilityNotExistException If app capabilities are not registered. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_capabilities ( self ) -> dict : \"\"\"Get app capabilities. Returns: App capabilities. Raises: AppCapabilityNotExistException: If app capabilities are not registered. \"\"\" try : record = self . _collection_data . query_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise raise AppCapabilityNotExistException ( \"App capabilities for %s have not been registered.\" % self . _app ) return record [ \"capabilities\" ]","title":"get_capabilities()"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.register_capabilities","text":"Register app capabilities. Parameters: Name Type Description Default capabilities dict App capabilities, example: { \u2018object_type1\u2019: { \u2018read\u2019: \u2018read_app_object_type1\u2019, \u2018write\u2019: \u2018write_app_object_type1\u2019, \u2018delete\u2019: \u2018delete_app_object_type1\u2019}, \u2018object_type2\u2019: { \u2018read\u2019: \u2018read_app_object_type2\u2019, \u2018write\u2019: \u2018write_app_object_type2\u2019, \u2018delete\u2019: \u2018delete_app_object_type2\u2019 }, \u2026 } required Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def register_capabilities ( self , capabilities : dict ): \"\"\"Register app capabilities. Arguments: capabilities: App capabilities, example: { 'object_type1': { 'read': 'read_app_object_type1', 'write': 'write_app_object_type1', 'delete': 'delete_app_object_type1'}, 'object_type2': { 'read': 'read_app_object_type2', 'write': 'write_app_object_type2', 'delete': 'delete_app_object_type2' }, ... } \"\"\" record = { \"_key\" : self . _app , \"capabilities\" : capabilities } self . _collection_data . batch_save ( record )","title":"register_capabilities()"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.unregister_capabilities","text":"Unregister app capabilities. Exceptions: Type Description AppCapabilityNotExistException If app capabilities are not registered. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def unregister_capabilities ( self ): \"\"\"Unregister app capabilities. Raises: AppCapabilityNotExistException: If app capabilities are not registered. \"\"\" try : self . _collection_data . delete_by_id ( self . _app ) except binding . HTTPError as e : if e . status != 404 : raise raise AppCapabilityNotExistException ( \"App capabilities for %s have not been registered.\" % self . _app )","title":"unregister_capabilities()"},{"location":"user_access/#solnlib.user_access.AppCapabilityManagerException","text":"Exception for AppCapabilityManager.","title":"AppCapabilityManagerException"},{"location":"user_access/#solnlib.user_access.AppCapabilityNotExistException","text":"Exception for the situation when AppCapability does not exist for a specific app.","title":"AppCapabilityNotExistException"},{"location":"user_access/#solnlib.user_access.InvalidSessionKeyException","text":"Exception when Splunk session key is invalid.","title":"InvalidSessionKeyException"},{"location":"user_access/#solnlib.user_access.ObjectACL","text":"Object ACL record. Examples: >>> from solnlib import user_access >>> obj_acl = user_access . ObjectACL ( >>> 'test_collection' , >>> '9defa6f510d711e6be16a45e60e34295' , >>> 'test_object' , >>> 'Splunk_TA_test' , >>> 'admin' , >>> { 'read' : [ '*' ], 'write' : [ 'admin' ], 'delete' : [ 'admin' ]}, >>> False )","title":"ObjectACL"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_APP_KEY","text":"","title":"OBJ_APP_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_COLLECTION_KEY","text":"","title":"OBJ_COLLECTION_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_ID_KEY","text":"","title":"OBJ_ID_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_OWNER_KEY","text":"","title":"OBJ_OWNER_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_ALLOW_ALL","text":"","title":"OBJ_PERMS_ALLOW_ALL"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_DELETE_KEY","text":"","title":"OBJ_PERMS_DELETE_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_KEY","text":"","title":"OBJ_PERMS_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_READ_KEY","text":"","title":"OBJ_PERMS_READ_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_WRITE_KEY","text":"","title":"OBJ_PERMS_WRITE_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_SHARED_BY_INCLUSION_KEY","text":"","title":"OBJ_SHARED_BY_INCLUSION_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_TYPE_KEY","text":"","title":"OBJ_TYPE_KEY"},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_perms","text":"","title":"obj_perms"},{"location":"user_access/#solnlib.user_access.ObjectACL.record","text":"Get object acl record. Returns: Object acl record, like: { '_key': 'test_collection-1234', 'obj_collection': 'test_collection', 'obj_id': '1234', 'obj_type': 'test_object', 'obj_app': 'Splunk_TA_test', 'obj_owner': 'admin', 'obj_perms': {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}, 'obj_shared_by_inclusion': True }","title":"record"},{"location":"user_access/#solnlib.user_access.ObjectACL.__init__","text":"Initializes ObjectACL. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: {\u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019]}. required obj_shared_by_inclusion bool Flag of object is shared by inclusion. required Source code in solnlib/user_access.py def __init__ ( self , obj_collection : str , obj_id : str , obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool , ): \"\"\"Initializes ObjectACL. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}. obj_shared_by_inclusion: Flag of object is shared by inclusion. \"\"\" self . obj_collection = obj_collection self . obj_id = obj_id self . obj_type = obj_type self . obj_app = obj_app self . obj_owner = obj_owner self . _check_perms ( obj_perms ) self . _obj_perms = obj_perms self . obj_shared_by_inclusion = obj_shared_by_inclusion","title":"__init__()"},{"location":"user_access/#solnlib.user_access.ObjectACL.__str__","text":"Source code in solnlib/user_access.py def __str__ ( self ): return json . dumps ( self . record )","title":"__str__()"},{"location":"user_access/#solnlib.user_access.ObjectACL.generate_key","text":"Generate object acl record key. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Returns: Type Description str Object acl record key. Source code in solnlib/user_access.py @staticmethod def generate_key ( obj_collection : str , obj_id : str ) -> str : \"\"\"Generate object acl record key. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Returns: Object acl record key. \"\"\" return \" {obj_collection} _ {obj_id} \" . format ( obj_collection = obj_collection , obj_id = obj_id )","title":"generate_key()"},{"location":"user_access/#solnlib.user_access.ObjectACL.merge","text":"Merge current object perms with perms of obj_acl . Parameters: Name Type Description Default obj_acl ObjectACL Object acl to merge. required Source code in solnlib/user_access.py def merge ( self , obj_acl : \"ObjectACL\" ): \"\"\"Merge current object perms with perms of `obj_acl`. Arguments: obj_acl: Object acl to merge. \"\"\" for perm_key in self . _obj_perms : self . _obj_perms [ perm_key ] = list ( set . union ( set ( self . _obj_perms [ perm_key ]), set ( obj_acl . _obj_perms [ perm_key ]) ) ) if self . OBJ_PERMS_ALLOW_ALL in self . _obj_perms [ perm_key ]: self . _obj_perms [ perm_key ] = [ self . OBJ_PERMS_ALLOW_ALL ]","title":"merge()"},{"location":"user_access/#solnlib.user_access.ObjectACL.parse","text":"Parse object acl record and construct a new ObjectACL object from it. Parameters: Name Type Description Default obj_acl_record dict Object acl record. required Returns: Type Description ObjectACL New ObjectACL object. Source code in solnlib/user_access.py @staticmethod def parse ( obj_acl_record : dict ) -> \"ObjectACL\" : \"\"\"Parse object acl record and construct a new `ObjectACL` object from it. Arguments: obj_acl_record: Object acl record. Returns: New `ObjectACL` object. \"\"\" return ObjectACL ( obj_acl_record [ ObjectACL . OBJ_COLLECTION_KEY ], obj_acl_record [ ObjectACL . OBJ_ID_KEY ], obj_acl_record [ ObjectACL . OBJ_TYPE_KEY ], obj_acl_record [ ObjectACL . OBJ_APP_KEY ], obj_acl_record [ ObjectACL . OBJ_OWNER_KEY ], obj_acl_record [ ObjectACL . OBJ_PERMS_KEY ], obj_acl_record [ ObjectACL . OBJ_SHARED_BY_INCLUSION_KEY ], )","title":"parse()"},{"location":"user_access/#solnlib.user_access.ObjectACLException","text":"","title":"ObjectACLException"},{"location":"user_access/#solnlib.user_access.ObjectACLManager","text":"Object ACL manager. Examples: >>> from solnlib import user_access >>> oaclm = user_access . ObjectACLManager ( session_key , 'Splunk_TA_test' )","title":"ObjectACLManager"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.__init__","text":"Initializes ObjectACLManager. Parameters: Name Type Description Default collection_name str Collection name to store object ACL info. required session_key str Splunk access token. required app str App name of namespace. required owner Optional[str] (optional) Owner of namespace, default is nobody . 'nobody' scheme Optional[str] (optional) The access scheme, default is None. None host Optional[str] (optional) The host name, default is None. None port Optional[int] (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description ObjectACLManagerException If init ObjectACLManager failed. Source code in solnlib/user_access.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : Optional [ str ] = \"nobody\" , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : dict , ): \"\"\"Initializes ObjectACLManager. Arguments: collection_name: Collection name to store object ACL info. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: ObjectACLManagerException: If init ObjectACLManager failed. \"\"\" collection_name = \" {app} _ {collection_name} \" . format ( app = app , collection_name = collection_name ) try : self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , None , ** context , ) except KeyError : raise ObjectACLManagerException ( f \"Get object acl collection: { collection_name } fail.\" )","title":"__init__()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.delete_acl","text":"Delete acl info. Query object acl info with parameter of the combination of obj_collection and obj_ids from KVStore and delete it. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Exceptions: Type Description ObjectACLNotExistException If object ACL info does not exist. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete_acl ( self , obj_collection : str , obj_id : str ): \"\"\"Delete acl info. Query object acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and delete it. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Raises: ObjectACLNotExistException: If object ACL info does not exist. \"\"\" key = ObjectACL . generate_key ( obj_collection , obj_id ) try : self . _collection_data . delete_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : raise raise ObjectACLNotExistException ( \"Object ACL info of {} _ {} does not exist.\" . format ( obj_collection , obj_id ) )","title":"delete_acl()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.delete_acls","text":"Batch delete acl info. Query objects acl info with parameter of the combination of obj_collection and obj_ids from KVStore and delete them. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete_acls ( self , obj_collection : str , obj_ids : List [ str ]): \"\"\"Batch delete acl info. Query objects acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and delete them. Arguments: obj_collection: Collection where object currently stored. obj_ids: IDs of objects. \"\"\" query = json . dumps ( { \"$or\" : [ { \"_key\" : ObjectACL . generate_key ( obj_collection , obj_id )} for obj_id in obj_ids ] } ) self . _collection_data . delete ( query = query )","title":"delete_acls()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_accessible_object_ids","text":"Get accessible IDs of objects from obj_acls . Parameters: Name Type Description Default user str User name of current operation . required operation str User operation, possible option: (read/write/delete). required obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Returns: Type Description List[str] List of IDs of accessible objects. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_accessible_object_ids ( self , user : str , operation : str , obj_collection : str , obj_ids : List [ str ] ) -> List [ str ]: \"\"\"Get accessible IDs of objects from `obj_acls`. Arguments: user: User name of current `operation`. operation: User operation, possible option: (read/write/delete). obj_collection: Collection where object currently stored. obj_ids: IDs of objects. Returns: List of IDs of accessible objects. \"\"\" obj_acls = self . get_acls ( obj_collection , obj_ids ) accessible_obj_ids = [] for obj_acl in obj_acls : perms = obj_acl . obj_perms [ operation ] if ObjectACL . OBJ_PERMS_ALLOW_ALL in perms or user in perms : accessible_obj_ids . append ( obj_acl . obj_id ) return accessible_obj_ids","title":"get_accessible_object_ids()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_acl","text":"Get acl info. Query object acl info with parameter of the combination of obj_collection and obj_id from self.collection_name and return it. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required Returns: Type Description ObjectACL Object acl info if success else None. Exceptions: Type Description ObjectACLNotExistException If object ACL info does not exist. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_acl ( self , obj_collection : str , obj_id : str ) -> \"ObjectACL\" : \"\"\"Get acl info. Query object acl info with parameter of the combination of `obj_collection` and `obj_id` from `self.collection_name` and return it. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. Returns: Object acl info if success else None. Raises: ObjectACLNotExistException: If object ACL info does not exist. \"\"\" key = ObjectACL . generate_key ( obj_collection , obj_id ) try : obj_acl = self . _collection_data . query_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : raise raise ObjectACLNotExistException ( \"Object ACL info of {} _ {} does not exist.\" . format ( obj_collection , obj_id ) ) return ObjectACL . parse ( obj_acl )","title":"get_acl()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_acls","text":"Batch get acl info. Query objects acl info with parameter of the combination of obj_collection and obj_ids from KVStore and return them. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_ids List[str] IDs of objects. required Returns: Type Description List[solnlib.user_access.ObjectACL] List of ObjectACL instances. Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_acls ( self , obj_collection : str , obj_ids : List [ str ]) -> List [ ObjectACL ]: \"\"\"Batch get acl info. Query objects acl info with parameter of the combination of `obj_collection` and `obj_ids` from KVStore and return them. Arguments: obj_collection: Collection where object currently stored. obj_ids: IDs of objects. Returns: List of `ObjectACL` instances. \"\"\" query = json . dumps ( { \"$or\" : [ { \"_key\" : ObjectACL . generate_key ( obj_collection , obj_id )} for obj_id in obj_ids ] } ) obj_acls = self . _collection_data . query ( query = query ) return [ ObjectACL . parse ( obj_acl ) for obj_acl in obj_acls ]","title":"get_acls()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.update_acl","text":"Update acl info of object. Construct a new object acl info first, if replace_existing is True then replace existing acl info else merge new object acl info with the old one and replace the old acl info with merged acl info. Parameters: Name Type Description Default obj_collection str Collection where object currently stored. required obj_id str ID of this object. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: { \u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019] }. required obj_shared_by_inclusion bool (optional) Flag of object is shared by inclusion, default is True. True replace_existing bool (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. True Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update_acl ( self , obj_collection : str , obj_id : str , obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool = True , replace_existing : bool = True , ): \"\"\"Update acl info of object. Construct a new object acl info first, if `replace_existing` is True then replace existing acl info else merge new object acl info with the old one and replace the old acl info with merged acl info. Arguments: obj_collection: Collection where object currently stored. obj_id: ID of this object. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: { 'read': ['*'], 'write': ['admin'], 'delete': ['admin'] }. obj_shared_by_inclusion: (optional) Flag of object is shared by inclusion, default is True. replace_existing: (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. \"\"\" obj_acl = ObjectACL ( obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion , ) if not replace_existing : try : old_obj_acl = self . get_acl ( obj_collection , obj_id ) except ObjectACLNotExistException : old_obj_acl = None if old_obj_acl : obj_acl . merge ( old_obj_acl ) self . _collection_data . batch_save ( obj_acl . record )","title":"update_acl()"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.update_acls","text":"Batch update object acl info to all provided obj_ids . Parameters: Name Type Description Default obj_collection str Collection where objects currently stored. required obj_ids List[str] IDs list of objects. required obj_type str Type of this object. required obj_app str App of this object. required obj_owner str Owner of this object. required obj_perms dict Object perms, like: { \u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019] }. required obj_shared_by_inclusion bool (optional) Flag of object is shared by inclusion, default is True. True replace_existing bool (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. True Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update_acls ( self , obj_collection : str , obj_ids : List [ str ], obj_type : str , obj_app : str , obj_owner : str , obj_perms : dict , obj_shared_by_inclusion : bool = True , replace_existing : bool = True , ): \"\"\"Batch update object acl info to all provided `obj_ids`. Arguments: obj_collection: Collection where objects currently stored. obj_ids: IDs list of objects. obj_type: Type of this object. obj_app: App of this object. obj_owner: Owner of this object. obj_perms: Object perms, like: { 'read': ['*'], 'write': ['admin'], 'delete': ['admin'] }. obj_shared_by_inclusion: (optional) Flag of object is shared by inclusion, default is True. replace_existing: (optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True. \"\"\" obj_acl_records = [] for obj_id in obj_ids : obj_acl = ObjectACL ( obj_collection , obj_id , obj_type , obj_app , obj_owner , obj_perms , obj_shared_by_inclusion , ) if not replace_existing : try : old_obj_acl = self . get_acl ( obj_collection , obj_id ) except ObjectACLNotExistException : old_obj_acl = None if old_obj_acl : obj_acl . merge ( old_obj_acl ) obj_acl_records . append ( obj_acl . record ) self . _collection_data . batch_save ( * obj_acl_records )","title":"update_acls()"},{"location":"user_access/#solnlib.user_access.ObjectACLManagerException","text":"Exception for ObjectACLManager.","title":"ObjectACLManagerException"},{"location":"user_access/#solnlib.user_access.ObjectACLNotExistException","text":"Exception for the situation when ACL does not exist.","title":"ObjectACLNotExistException"},{"location":"user_access/#solnlib.user_access.UserAccessException","text":"Exception for the situation when there is user access exception.","title":"UserAccessException"},{"location":"user_access/#solnlib.user_access.UserNotExistException","text":"Exception when user does not exist.","title":"UserNotExistException"},{"location":"user_access/#solnlib.user_access.check_user_access","text":"User access checker. It will fetch user capabilities from given session_key and check if the capability extracted from capabilities , obj_type and operation is contained, if user capabilities include the extracted capability user access is ok else fail. Parameters: Name Type Description Default session_key str Splunk access token. required capabilities dict App capabilities, example: { \u2018object_type1\u2019: { \u2018read\u2019: \u2018read_app_object_type1\u2019, \u2018write\u2019: \u2018write_app_object_type1\u2019, \u2018delete\u2019: \u2018delete_app_object_type1\u2019}, \u2018object_type2\u2019: { \u2018read\u2019: \u2018read_app_object_type2\u2019, \u2018write\u2019: \u2018write_app_object_type2\u2019, \u2018delete\u2019: \u2018delete_app_object_type2\u2019 }, \u2026 } required obj_type str Object type. required operation str User operation, possible option: (read/write/delete). required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Exceptions: Type Description UserAccessException If user access permission is denied. Examples: >>> from solnlib.user_access import check_user_access >>> def fun (): >>> check_user_access ( >>> session_key , capabilities , 'test_object' , 'read' ) >>> ... Source code in solnlib/user_access.py def check_user_access ( session_key : str , capabilities : dict , obj_type : str , operation : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ): \"\"\"User access checker. It will fetch user capabilities from given `session_key` and check if the capability extracted from `capabilities`, `obj_type` and `operation` is contained, if user capabilities include the extracted capability user access is ok else fail. Arguments: session_key: Splunk access token. capabilities: App capabilities, example: { 'object_type1': { 'read': 'read_app_object_type1', 'write': 'write_app_object_type1', 'delete': 'delete_app_object_type1'}, 'object_type2': { 'read': 'read_app_object_type2', 'write': 'write_app_object_type2', 'delete': 'delete_app_object_type2' }, ... } obj_type: Object type. operation: User operation, possible option: (read/write/delete). scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: UserAccessException: If user access permission is denied. Examples: >>> from solnlib.user_access import check_user_access >>> def fun(): >>> check_user_access( >>> session_key, capabilities, 'test_object', 'read') >>> ... \"\"\" username = get_current_username ( session_key , scheme = scheme , host = host , port = port , ** context ) capability = capabilities [ obj_type ][ operation ] if not user_is_capable ( session_key , username , capability , scheme = scheme , host = host , port = port , ** context , ): raise UserAccessException ( \"Permission denied, %s does not have the capability: %s .\" % ( username , capability ) )","title":"check_user_access()"},{"location":"user_access/#solnlib.user_access.get_current_username","text":"Get current user name from session_key . Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description str Current user name. Exceptions: Type Description InvalidSessionKeyException If session_key is invalid. Examples: >>> from solnlib import user_access >>> user_name = user_access . get_current_username ( session_key ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_current_username ( session_key : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> str : \"\"\"Get current user name from `session_key`. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: Current user name. Raises: InvalidSessionKeyException: If `session_key` is invalid. Examples: >>> from solnlib import user_access >>> user_name = user_access.get_current_username(session_key) \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) try : response = _rest_client . get ( \"/services/authentication/current-context\" , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 401 : raise raise InvalidSessionKeyException ( \"Invalid session key.\" ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"username\" ]","title":"get_current_username()"},{"location":"user_access/#solnlib.user_access.get_user_capabilities","text":"Get user capabilities. Parameters: Name Type Description Default session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description List[dict] User capabilities. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> user_capabilities = user_access . get_user_capabilities ( >>> session_key , 'test_user' ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_user_capabilities ( session_key : str , username : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> List [ dict ]: \"\"\"Get user capabilities. Arguments: session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: User capabilities. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> user_capabilities = user_access.get_user_capabilities( >>> session_key, 'test_user') \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) url = f \"/services/authentication/users/ { username } \" try : response = _rest_client . get ( url , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise UserNotExistException ( \"User: %s does not exist.\" % username ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"capabilities\" ]","title":"get_user_capabilities()"},{"location":"user_access/#solnlib.user_access.get_user_roles","text":"Get user roles. Parameters: Name Type Description Default session_key str Splunk access token. required username str (optional) User name of roles to get. required scheme (optional) The access scheme, default is None. None host (optional) The host name, default is None. None port (optional) The port number, default is None. None context Other configurations for Splunk rest client. {} Returns: Type Description List User roles. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> user_roles = user_access . get_user_roles ( session_key , 'test_user' ) Source code in solnlib/user_access.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get_user_roles ( session_key : str , username : str , scheme = None , host = None , port = None , ** context ) -> List : \"\"\"Get user roles. Arguments: session_key: Splunk access token. username: (optional) User name of roles to get. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: User roles. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> user_roles = user_access.get_user_roles(session_key, 'test_user') \"\"\" _rest_client = rest_client . SplunkRestClient ( session_key , \"-\" , scheme = scheme , host = host , port = port , ** context ) url = f \"/services/authentication/users/ { username } \" try : response = _rest_client . get ( url , output_mode = \"json\" ) . body . read () except binding . HTTPError as e : if e . status != 404 : raise raise UserNotExistException ( \"User: %s does not exist.\" % username ) return json . loads ( response )[ \"entry\" ][ 0 ][ \"content\" ][ \"roles\" ]","title":"get_user_roles()"},{"location":"user_access/#solnlib.user_access.user_is_capable","text":"Check if user is capable for given capability . Parameters: Name Type Description Default session_key str Splunk access token. required username str (optional) User name of roles to get. required capability str The capability we wish to check for. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None context dict Other configurations for Splunk rest client. {} Returns: Type Description bool True if user is capable else False. Exceptions: Type Description UserNotExistException If username does not exist. Examples: >>> from solnlib import user_access >>> is_capable = user_access . user_is_capable ( >>> session_key , 'test_user' , 'object_read_capability' ) Source code in solnlib/user_access.py def user_is_capable ( session_key : str , username : str , capability : str , scheme : str = None , host : str = None , port : int = None , ** context : dict , ) -> bool : \"\"\"Check if user is capable for given `capability`. Arguments: session_key: Splunk access token. username: (optional) User name of roles to get. capability: The capability we wish to check for. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Returns: True if user is capable else False. Raises: UserNotExistException: If `username` does not exist. Examples: >>> from solnlib import user_access >>> is_capable = user_access.user_is_capable( >>> session_key, 'test_user', 'object_read_capability') \"\"\" capabilities = get_user_capabilities ( session_key , username , scheme = scheme , host = host , port = port , ** context ) return capability in capabilities","title":"user_is_capable()"},{"location":"utils/","text":"Common utilities. __all__ special \u00b6 datetime_to_seconds ( dt ) \u00b6 Convert UTC datetime to seconds since epoch. Parameters: Name Type Description Default dt datetime Date time. required Returns: Type Description float Seconds since epoch. Source code in solnlib/utils.py def datetime_to_seconds ( dt : datetime . datetime ) -> float : \"\"\"Convert UTC datetime to seconds since epoch. Arguments: dt: Date time. Returns: Seconds since epoch. \"\"\" epoch_time = datetime . datetime . utcfromtimestamp ( 0 ) return ( dt - epoch_time ) . total_seconds () extract_http_scheme_host_port ( http_url ) \u00b6 Extract scheme, host and port from a HTTP URL. Parameters: Name Type Description Default http_url str HTTP URL to extract. required Returns: Type Description Tuple A tuple of scheme, host and port Exceptions: Type Description ValueError If http_url is not in http(s)://hostname:port format. Source code in solnlib/utils.py def extract_http_scheme_host_port ( http_url : str ) -> Tuple : \"\"\"Extract scheme, host and port from a HTTP URL. Arguments: http_url: HTTP URL to extract. Returns: A tuple of scheme, host and port Raises: ValueError: If `http_url` is not in http(s)://hostname:port format. \"\"\" try : http_info = urlparse . urlparse ( http_url ) except Exception : raise ValueError ( str ( http_url ) + \" is not in http(s)://hostname:port format\" ) if not http_info . scheme or not http_info . hostname or not http_info . port : raise ValueError ( http_url + \" is not in http(s)://hostname:port format\" ) return http_info . scheme , http_info . hostname , http_info . port handle_teardown_signals ( callback ) \u00b6 Register handler for SIGTERM/SIGINT/SIGBREAK signal. Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback Note: this should be called in main thread since Python only catches signals in main thread. Parameters: Name Type Description Default callback Callable Callback for tear down signals. required Source code in solnlib/utils.py def handle_teardown_signals ( callback : Callable ): \"\"\"Register handler for SIGTERM/SIGINT/SIGBREAK signal. Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback Note: this should be called in main thread since Python only catches signals in main thread. Arguments: callback: Callback for tear down signals. \"\"\" signal . signal ( signal . SIGTERM , callback ) signal . signal ( signal . SIGINT , callback ) if os . name == \"nt\" : signal . signal ( signal . SIGBREAK , callback ) is_false ( val ) \u00b6 Decide if val is false. Parameters: Name Type Description Default val Union[str, int] Value to check. required Returns: Type Description bool True or False. Source code in solnlib/utils.py def is_false ( val : Union [ str , int ]) -> bool : \"\"\"Decide if `val` is false. Arguments: val: Value to check. Returns: True or False. \"\"\" value = str ( val ) . strip () . upper () if value in ( \"0\" , \"FALSE\" , \"F\" , \"N\" , \"NO\" , \"NONE\" , \"\" ): return True return False is_true ( val ) \u00b6 Decide if val is true. Parameters: Name Type Description Default val Union[str, int] Value to check. required Returns: Type Description bool True or False. Source code in solnlib/utils.py def is_true ( val : Union [ str , int ]) -> bool : \"\"\"Decide if `val` is true. Arguments: val: Value to check. Returns: True or False. \"\"\" value = str ( val ) . strip () . upper () if value in ( \"1\" , \"TRUE\" , \"T\" , \"Y\" , \"YES\" ): return True return False retry ( retries = 3 , reraise = True , default_return = None , exceptions = None ) \u00b6 A decorator to run function with max retries times if there is exception. Parameters: Name Type Description Default retries int (optional) Max retries times, default is 3. 3 reraise bool Whether exception should be reraised, default is True. True default_return Any (optional) Default return value for function run after max retries and reraise is False. None exceptions List (optional) List of exceptions that should retry. None Source code in solnlib/utils.py def retry ( retries : int = 3 , reraise : bool = True , default_return : Any = None , exceptions : List = None , ): \"\"\"A decorator to run function with max `retries` times if there is exception. Arguments: retries: (optional) Max retries times, default is 3. reraise: Whether exception should be reraised, default is True. default_return: (optional) Default return value for function run after max retries and reraise is False. exceptions: (optional) List of exceptions that should retry. \"\"\" max_tries = max ( retries , 0 ) + 1 def do_retry ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): last_ex = None for i in range ( max_tries ): try : return func ( * args , ** kwargs ) except Exception as e : logging . warning ( \"Run function: %s failed: %s .\" , func . __name__ , traceback . format_exc (), ) if not exceptions or any ( isinstance ( e , exception ) for exception in exceptions ): last_ex = e if i < max_tries - 1 : time . sleep ( 2 ** i ) else : raise if reraise : raise last_ex else : return default_return return wrapper return do_retry","title":"utils.py"},{"location":"utils/#solnlib.utils.__all__","text":"","title":"__all__"},{"location":"utils/#solnlib.utils.datetime_to_seconds","text":"Convert UTC datetime to seconds since epoch. Parameters: Name Type Description Default dt datetime Date time. required Returns: Type Description float Seconds since epoch. Source code in solnlib/utils.py def datetime_to_seconds ( dt : datetime . datetime ) -> float : \"\"\"Convert UTC datetime to seconds since epoch. Arguments: dt: Date time. Returns: Seconds since epoch. \"\"\" epoch_time = datetime . datetime . utcfromtimestamp ( 0 ) return ( dt - epoch_time ) . total_seconds ()","title":"datetime_to_seconds()"},{"location":"utils/#solnlib.utils.extract_http_scheme_host_port","text":"Extract scheme, host and port from a HTTP URL. Parameters: Name Type Description Default http_url str HTTP URL to extract. required Returns: Type Description Tuple A tuple of scheme, host and port Exceptions: Type Description ValueError If http_url is not in http(s)://hostname:port format. Source code in solnlib/utils.py def extract_http_scheme_host_port ( http_url : str ) -> Tuple : \"\"\"Extract scheme, host and port from a HTTP URL. Arguments: http_url: HTTP URL to extract. Returns: A tuple of scheme, host and port Raises: ValueError: If `http_url` is not in http(s)://hostname:port format. \"\"\" try : http_info = urlparse . urlparse ( http_url ) except Exception : raise ValueError ( str ( http_url ) + \" is not in http(s)://hostname:port format\" ) if not http_info . scheme or not http_info . hostname or not http_info . port : raise ValueError ( http_url + \" is not in http(s)://hostname:port format\" ) return http_info . scheme , http_info . hostname , http_info . port","title":"extract_http_scheme_host_port()"},{"location":"utils/#solnlib.utils.handle_teardown_signals","text":"Register handler for SIGTERM/SIGINT/SIGBREAK signal. Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback Note: this should be called in main thread since Python only catches signals in main thread. Parameters: Name Type Description Default callback Callable Callback for tear down signals. required Source code in solnlib/utils.py def handle_teardown_signals ( callback : Callable ): \"\"\"Register handler for SIGTERM/SIGINT/SIGBREAK signal. Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback Note: this should be called in main thread since Python only catches signals in main thread. Arguments: callback: Callback for tear down signals. \"\"\" signal . signal ( signal . SIGTERM , callback ) signal . signal ( signal . SIGINT , callback ) if os . name == \"nt\" : signal . signal ( signal . SIGBREAK , callback )","title":"handle_teardown_signals()"},{"location":"utils/#solnlib.utils.is_false","text":"Decide if val is false. Parameters: Name Type Description Default val Union[str, int] Value to check. required Returns: Type Description bool True or False. Source code in solnlib/utils.py def is_false ( val : Union [ str , int ]) -> bool : \"\"\"Decide if `val` is false. Arguments: val: Value to check. Returns: True or False. \"\"\" value = str ( val ) . strip () . upper () if value in ( \"0\" , \"FALSE\" , \"F\" , \"N\" , \"NO\" , \"NONE\" , \"\" ): return True return False","title":"is_false()"},{"location":"utils/#solnlib.utils.is_true","text":"Decide if val is true. Parameters: Name Type Description Default val Union[str, int] Value to check. required Returns: Type Description bool True or False. Source code in solnlib/utils.py def is_true ( val : Union [ str , int ]) -> bool : \"\"\"Decide if `val` is true. Arguments: val: Value to check. Returns: True or False. \"\"\" value = str ( val ) . strip () . upper () if value in ( \"1\" , \"TRUE\" , \"T\" , \"Y\" , \"YES\" ): return True return False","title":"is_true()"},{"location":"utils/#solnlib.utils.retry","text":"A decorator to run function with max retries times if there is exception. Parameters: Name Type Description Default retries int (optional) Max retries times, default is 3. 3 reraise bool Whether exception should be reraised, default is True. True default_return Any (optional) Default return value for function run after max retries and reraise is False. None exceptions List (optional) List of exceptions that should retry. None Source code in solnlib/utils.py def retry ( retries : int = 3 , reraise : bool = True , default_return : Any = None , exceptions : List = None , ): \"\"\"A decorator to run function with max `retries` times if there is exception. Arguments: retries: (optional) Max retries times, default is 3. reraise: Whether exception should be reraised, default is True. default_return: (optional) Default return value for function run after max retries and reraise is False. exceptions: (optional) List of exceptions that should retry. \"\"\" max_tries = max ( retries , 0 ) + 1 def do_retry ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): last_ex = None for i in range ( max_tries ): try : return func ( * args , ** kwargs ) except Exception as e : logging . warning ( \"Run function: %s failed: %s .\" , func . __name__ , traceback . format_exc (), ) if not exceptions or any ( isinstance ( e , exception ) for exception in exceptions ): last_ex = e if i < max_tries - 1 : time . sleep ( 2 ** i ) else : raise if reraise : raise last_ex else : return default_return return wrapper return do_retry","title":"retry()"},{"location":"modular_input/checkpointer/","text":"This module provides two kinds of checkpointer: KVStoreCheckpointer, FileCheckpointer for modular input to save checkpoint. __all__ special \u00b6 Checkpointer \u00b6 Base class of checkpointer. batch_update ( self , states ) \u00b6 Batch update checkpoint. Parameters: Name Type Description Default states List List of checkpoint. Each state in the list is a json object which should contain \u2018_key\u2019 and \u2018state\u2019 keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . batch_update ([{ '_key' : 'checkpoint_name1' , 'state' : { 'k1' : 'v1' , 'k2' : 'v2' }}, { '_key' : 'checkpoint_name2' , 'state' : 'checkpoint_value2' }, { ... }]) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def batch_update ( self , states : List ): \"\"\"Batch update checkpoint. Arguments: states: List of checkpoint. Each state in the list is a json object which should contain '_key' and 'state' keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.batch_update([{'_key': 'checkpoint_name1', 'state': {'k1': 'v1', 'k2': 'v2'}}, {'_key': 'checkpoint_name2', 'state': 'checkpoint_value2'}, {...}]) \"\"\" pass delete ( self , key ) \u00b6 Delete checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . delete ( 'checkpoint_name1' ) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def delete ( self , key : str ): \"\"\"Delete checkpoint. Arguments: key: Checkpoint key. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.delete('checkpoint_name1') \"\"\" pass get ( self , key ) \u00b6 Get checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required Returns: Type Description dict Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . get ( 'checkpoint_name1' ) >>> returns : { 'k1' : 'v1' , 'k2' : 'v2' } Source code in solnlib/modular_input/checkpointer.py @abstractmethod def get ( self , key : str ) -> dict : \"\"\"Get checkpoint. Arguments: key: Checkpoint key. Returns: Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.get('checkpoint_name1') >>> returns: {'k1': 'v1', 'k2': 'v2'} \"\"\" pass update ( self , key , state ) \u00b6 Update checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required state dict Checkpoint state. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . update ( 'checkpoint_name1' , { 'k1' : 'v1' , 'k2' : 'v2' }) >>> ck . update ( 'checkpoint_name2' , 'checkpoint_value2' ) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def update ( self , key : str , state : dict ): \"\"\"Update checkpoint. Arguments: key: Checkpoint key. state: Checkpoint state. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.update('checkpoint_name1', {'k1': 'v1', 'k2': 'v2'}) >>> ck.update('checkpoint_name2', 'checkpoint_value2') \"\"\" pass CheckpointerException ( Exception ) \u00b6 FileCheckpointer ( Checkpointer ) \u00b6 File checkpointer. Use file to save modular input checkpoint. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . FileCheckpointer ( '/opt/splunk/var/...' ) >>> ck . update ( ... ) >>> ck . get ( ... ) __init__ ( self , checkpoint_dir ) special \u00b6 Initializes FileCheckpointer. Parameters: Name Type Description Default checkpoint_dir str Checkpoint directory. required Source code in solnlib/modular_input/checkpointer.py def __init__ ( self , checkpoint_dir : str ): \"\"\"Initializes FileCheckpointer. Arguments: checkpoint_dir: Checkpoint directory. \"\"\" self . _checkpoint_dir = checkpoint_dir batch_update ( self , states ) \u00b6 Batch update checkpoint. Parameters: Name Type Description Default states List of checkpoint. Each state in the list is a json object which should contain \u2018_key\u2019 and \u2018state\u2019 keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . batch_update ([{ '_key' : 'checkpoint_name1' , 'state' : { 'k1' : 'v1' , 'k2' : 'v2' }}, { '_key' : 'checkpoint_name2' , 'state' : 'checkpoint_value2' }, { ... }]) Source code in solnlib/modular_input/checkpointer.py def batch_update ( self , states ): for state in states : self . update ( state [ \"_key\" ], state [ \"state\" ]) delete ( self , key ) \u00b6 Delete checkpoint. Parameters: Name Type Description Default key Checkpoint key. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . delete ( 'checkpoint_name1' ) Source code in solnlib/modular_input/checkpointer.py def delete ( self , key ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) try : os . remove ( file_name ) except OSError : pass encode_key ( self , key ) \u00b6 Source code in solnlib/modular_input/checkpointer.py def encode_key ( self , key ): return base64 . b64encode ( key . encode ()) . decode () get ( self , key ) \u00b6 Get checkpoint. Parameters: Name Type Description Default key Checkpoint key. required Returns: Type Description Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . get ( 'checkpoint_name1' ) >>> returns : { 'k1' : 'v1' , 'k2' : 'v2' } Source code in solnlib/modular_input/checkpointer.py def get ( self , key ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) try : with open ( file_name ) as fp : return json . load ( fp ) except ( OSError , ValueError ): return None update ( self , key , state ) \u00b6 Update checkpoint. Parameters: Name Type Description Default key Checkpoint key. required state Checkpoint state. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . update ( 'checkpoint_name1' , { 'k1' : 'v1' , 'k2' : 'v2' }) >>> ck . update ( 'checkpoint_name2' , 'checkpoint_value2' ) Source code in solnlib/modular_input/checkpointer.py def update ( self , key , state ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) with open ( file_name + \"_new\" , \"w\" ) as fp : json . dump ( state , fp ) if op . exists ( file_name ): try : os . remove ( file_name ) except OSError : pass os . rename ( file_name + \"_new\" , file_name ) KVStoreCheckpointer ( Checkpointer ) \u00b6 KVStore checkpointer. Use KVStore to save modular input checkpoint. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpoint . KVStoreCheckpointer ( 'TestKVStoreCheckpointer' , session_key , 'Splunk_TA_test' ) >>> ck . update ( ... ) >>> ck . get ( ... ) __init__ ( self , collection_name , session_key , app , owner = 'nobody' , scheme = None , host = None , port = None , ** context ) special \u00b6 Initializes KVStoreCheckpointer. Parameters: Name Type Description Default collection_name str Collection name of kvstore checkpointer. required session_key str Splunk access token. required app str App name of namespace. required owner Optional[str] (optional) Owner of namespace, default is nobody . 'nobody' scheme Optional[str] (optional) The access scheme, default is None. None host Optional[str] (optional) The host name, default is None. None port Optional[int] (optional) The port number, default is None. None context Any Other configurations for Splunk rest client. {} Exceptions: Type Description CheckpointerException If init KV Store checkpointer failed. Source code in solnlib/modular_input/checkpointer.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : Optional [ str ] = \"nobody\" , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : Any ): \"\"\"Initializes KVStoreCheckpointer. Arguments: collection_name: Collection name of kvstore checkpointer. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: CheckpointerException: If init KV Store checkpointer failed. \"\"\" try : if not context . get ( \"pool_connections\" ): context [ \"pool_connections\" ] = 5 if not context . get ( \"pool_maxsize\" ): context [ \"pool_maxsize\" ] = 5 self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , { \"state\" : \"string\" }, ** context , ) except KeyError : raise CheckpointerException ( \"Get kvstore checkpointer failed.\" ) batch_update ( self , states ) \u00b6 Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def batch_update ( self , states ): for state in states : state [ \"state\" ] = json . dumps ( state [ \"state\" ]) self . _collection_data . batch_save ( * states ) delete ( self , key ) \u00b6 Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete ( self , key ): try : self . _collection_data . delete_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : logging . error ( \"Delete checkpoint failed: %s .\" , traceback . format_exc ()) raise get ( self , key ) \u00b6 Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get ( self , key ): try : record = self . _collection_data . query_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : logging . error ( \"Get checkpoint failed: %s .\" , traceback . format_exc ()) raise return None return json . loads ( record [ \"state\" ]) update ( self , key , state ) \u00b6 Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update ( self , key , state ): record = { \"_key\" : key , \"state\" : json . dumps ( state )} # ZEP: why batch_save? update as alternative? self . _collection_data . batch_save ( record )","title":"checkpointer.py"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.__all__","text":"","title":"__all__"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer","text":"Base class of checkpointer.","title":"Checkpointer"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.batch_update","text":"Batch update checkpoint. Parameters: Name Type Description Default states List List of checkpoint. Each state in the list is a json object which should contain \u2018_key\u2019 and \u2018state\u2019 keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . batch_update ([{ '_key' : 'checkpoint_name1' , 'state' : { 'k1' : 'v1' , 'k2' : 'v2' }}, { '_key' : 'checkpoint_name2' , 'state' : 'checkpoint_value2' }, { ... }]) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def batch_update ( self , states : List ): \"\"\"Batch update checkpoint. Arguments: states: List of checkpoint. Each state in the list is a json object which should contain '_key' and 'state' keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.batch_update([{'_key': 'checkpoint_name1', 'state': {'k1': 'v1', 'k2': 'v2'}}, {'_key': 'checkpoint_name2', 'state': 'checkpoint_value2'}, {...}]) \"\"\" pass","title":"batch_update()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.delete","text":"Delete checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . delete ( 'checkpoint_name1' ) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def delete ( self , key : str ): \"\"\"Delete checkpoint. Arguments: key: Checkpoint key. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.delete('checkpoint_name1') \"\"\" pass","title":"delete()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.get","text":"Get checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required Returns: Type Description dict Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . get ( 'checkpoint_name1' ) >>> returns : { 'k1' : 'v1' , 'k2' : 'v2' } Source code in solnlib/modular_input/checkpointer.py @abstractmethod def get ( self , key : str ) -> dict : \"\"\"Get checkpoint. Arguments: key: Checkpoint key. Returns: Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.get('checkpoint_name1') >>> returns: {'k1': 'v1', 'k2': 'v2'} \"\"\" pass","title":"get()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.update","text":"Update checkpoint. Parameters: Name Type Description Default key str Checkpoint key. required state dict Checkpoint state. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . update ( 'checkpoint_name1' , { 'k1' : 'v1' , 'k2' : 'v2' }) >>> ck . update ( 'checkpoint_name2' , 'checkpoint_value2' ) Source code in solnlib/modular_input/checkpointer.py @abstractmethod def update ( self , key : str , state : dict ): \"\"\"Update checkpoint. Arguments: key: Checkpoint key. state: Checkpoint state. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer.KVStoreCheckpointer(session_key, 'Splunk_TA_test') >>> ck.update('checkpoint_name1', {'k1': 'v1', 'k2': 'v2'}) >>> ck.update('checkpoint_name2', 'checkpoint_value2') \"\"\" pass","title":"update()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.CheckpointerException","text":"","title":"CheckpointerException"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer","text":"File checkpointer. Use file to save modular input checkpoint. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . FileCheckpointer ( '/opt/splunk/var/...' ) >>> ck . update ( ... ) >>> ck . get ( ... )","title":"FileCheckpointer"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.__init__","text":"Initializes FileCheckpointer. Parameters: Name Type Description Default checkpoint_dir str Checkpoint directory. required Source code in solnlib/modular_input/checkpointer.py def __init__ ( self , checkpoint_dir : str ): \"\"\"Initializes FileCheckpointer. Arguments: checkpoint_dir: Checkpoint directory. \"\"\" self . _checkpoint_dir = checkpoint_dir","title":"__init__()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.batch_update","text":"Batch update checkpoint. Parameters: Name Type Description Default states List of checkpoint. Each state in the list is a json object which should contain \u2018_key\u2019 and \u2018state\u2019 keys. For instance:: { '_key': ckpt key which is a string, 'state': ckpt which is a json object } required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . batch_update ([{ '_key' : 'checkpoint_name1' , 'state' : { 'k1' : 'v1' , 'k2' : 'v2' }}, { '_key' : 'checkpoint_name2' , 'state' : 'checkpoint_value2' }, { ... }]) Source code in solnlib/modular_input/checkpointer.py def batch_update ( self , states ): for state in states : self . update ( state [ \"_key\" ], state [ \"state\" ])","title":"batch_update()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.delete","text":"Delete checkpoint. Parameters: Name Type Description Default key Checkpoint key. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . delete ( 'checkpoint_name1' ) Source code in solnlib/modular_input/checkpointer.py def delete ( self , key ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) try : os . remove ( file_name ) except OSError : pass","title":"delete()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.encode_key","text":"Source code in solnlib/modular_input/checkpointer.py def encode_key ( self , key ): return base64 . b64encode ( key . encode ()) . decode ()","title":"encode_key()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.get","text":"Get checkpoint. Parameters: Name Type Description Default key Checkpoint key. required Returns: Type Description Checkpoint state if exists else None. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . get ( 'checkpoint_name1' ) >>> returns : { 'k1' : 'v1' , 'k2' : 'v2' } Source code in solnlib/modular_input/checkpointer.py def get ( self , key ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) try : with open ( file_name ) as fp : return json . load ( fp ) except ( OSError , ValueError ): return None","title":"get()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.update","text":"Update checkpoint. Parameters: Name Type Description Default key Checkpoint key. required state Checkpoint state. required Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpointer . KVStoreCheckpointer ( session_key , 'Splunk_TA_test' ) >>> ck . update ( 'checkpoint_name1' , { 'k1' : 'v1' , 'k2' : 'v2' }) >>> ck . update ( 'checkpoint_name2' , 'checkpoint_value2' ) Source code in solnlib/modular_input/checkpointer.py def update ( self , key , state ): file_name = op . join ( self . _checkpoint_dir , self . encode_key ( key )) with open ( file_name + \"_new\" , \"w\" ) as fp : json . dump ( state , fp ) if op . exists ( file_name ): try : os . remove ( file_name ) except OSError : pass os . rename ( file_name + \"_new\" , file_name )","title":"update()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer","text":"KVStore checkpointer. Use KVStore to save modular input checkpoint. Examples: >>> from solnlib.modular_input import checkpointer >>> ck = checkpoint . KVStoreCheckpointer ( 'TestKVStoreCheckpointer' , session_key , 'Splunk_TA_test' ) >>> ck . update ( ... ) >>> ck . get ( ... )","title":"KVStoreCheckpointer"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.__init__","text":"Initializes KVStoreCheckpointer. Parameters: Name Type Description Default collection_name str Collection name of kvstore checkpointer. required session_key str Splunk access token. required app str App name of namespace. required owner Optional[str] (optional) Owner of namespace, default is nobody . 'nobody' scheme Optional[str] (optional) The access scheme, default is None. None host Optional[str] (optional) The host name, default is None. None port Optional[int] (optional) The port number, default is None. None context Any Other configurations for Splunk rest client. {} Exceptions: Type Description CheckpointerException If init KV Store checkpointer failed. Source code in solnlib/modular_input/checkpointer.py def __init__ ( self , collection_name : str , session_key : str , app : str , owner : Optional [ str ] = \"nobody\" , scheme : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None , ** context : Any ): \"\"\"Initializes KVStoreCheckpointer. Arguments: collection_name: Collection name of kvstore checkpointer. session_key: Splunk access token. app: App name of namespace. owner: (optional) Owner of namespace, default is `nobody`. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. context: Other configurations for Splunk rest client. Raises: CheckpointerException: If init KV Store checkpointer failed. \"\"\" try : if not context . get ( \"pool_connections\" ): context [ \"pool_connections\" ] = 5 if not context . get ( \"pool_maxsize\" ): context [ \"pool_maxsize\" ] = 5 self . _collection_data = _utils . get_collection_data ( collection_name , session_key , app , owner , scheme , host , port , { \"state\" : \"string\" }, ** context , ) except KeyError : raise CheckpointerException ( \"Get kvstore checkpointer failed.\" )","title":"__init__()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.batch_update","text":"Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def batch_update ( self , states ): for state in states : state [ \"state\" ] = json . dumps ( state [ \"state\" ]) self . _collection_data . batch_save ( * states )","title":"batch_update()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.delete","text":"Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def delete ( self , key ): try : self . _collection_data . delete_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : logging . error ( \"Delete checkpoint failed: %s .\" , traceback . format_exc ()) raise","title":"delete()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.get","text":"Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def get ( self , key ): try : record = self . _collection_data . query_by_id ( key ) except binding . HTTPError as e : if e . status != 404 : logging . error ( \"Get checkpoint failed: %s .\" , traceback . format_exc ()) raise return None return json . loads ( record [ \"state\" ])","title":"get()"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.update","text":"Source code in solnlib/modular_input/checkpointer.py @utils . retry ( exceptions = [ binding . HTTPError ]) def update ( self , key , state ): record = { \"_key\" : key , \"state\" : json . dumps ( state )} # ZEP: why batch_save? update as alternative? self . _collection_data . batch_save ( record )","title":"update()"},{"location":"modular_input/event/","text":"This module provides Splunk modular input event encapsulation. __all__ special \u00b6 Event \u00b6 Base class of modular input event. __init__ ( self , data , time = None , index = None , host = None , source = None , sourcetype = None , fields = None , stanza = None , unbroken = False , done = False ) special \u00b6 Modular input event. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. False done bool (optional) The last unbroken event, default is False. False Examples: >>> event = Event ( >>> data = 'This is a test data.' , >>> time = 1372274622.493 , >>> index = 'main' , >>> host = 'localhost' , >>> source = 'Splunk' , >>> sourcetype = 'misc' , >>> fields = { 'Cloud' : 'AWS' , 'region' : 'us-west-1' }, >>> stanza = 'test_scheme://test' , >>> unbroken = True , >>> done = True ) Source code in solnlib/modular_input/event.py def __init__ ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ): \"\"\"Modular input event. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. done: (optional) The last unbroken event, default is False. Examples: >>> event = Event( >>> data='This is a test data.', >>> time=1372274622.493, >>> index='main', >>> host='localhost', >>> source='Splunk', >>> sourcetype='misc', >>> fields= {'Cloud':'AWS','region': 'us-west-1'}, >>> stanza='test_scheme://test', >>> unbroken=True, >>> done=True) \"\"\" self . _data = data self . _time = \" %.3f \" % time if time else None self . _index = index self . _host = host self . _source = source self . _sourcetype = sourcetype if fields : self . _fields = fields self . _stanza = stanza if not unbroken and done : raise EventException ( 'Invalid combination of \"unbroken\" and \"done\".' ) self . _unbroken = unbroken self . _done = done __str__ ( self ) special \u00b6 Source code in solnlib/modular_input/event.py def __str__ ( self ): event = { \"data\" : self . _data , \"time\" : float ( self . _time ) if self . _time else self . _time , \"index\" : self . _index , \"host\" : self . _host , \"source\" : self . _source , \"sourcetype\" : self . _sourcetype , \"stanza\" : self . _stanza , \"unbroken\" : self . _unbroken , \"done\" : self . _done , } if hasattr ( self , \"_fields\" ): event [ \"fields\" ] = self . _fields return json . dumps ( event ) format_events ( events ) classmethod \u00b6 Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required Returns: Type Description List List of formatted events string. Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. Returns: List of formatted events string. \"\"\" raise EventException ( 'Unimplemented \"format_events\".' ) EventException ( Exception ) \u00b6 HECEvent ( Event ) \u00b6 HEC event. max_hec_event_length \u00b6 format_events ( events , event_field = 'event' ) classmethod \u00b6 Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required event_field str Event field. 'event' Returns: Type Description List of formatted events string, example : [ '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\n {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}', '...' ] Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List , event_field : str = \"event\" ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. event_field: Event field. Returns: List of formatted events string, example:: [ '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\\\n {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}', '...' ] \"\"\" size = 0 new_events , batched_events = [], [] events = [ event . _to_hec ( event_field ) for event in events ] for event in events : new_length = size + len ( event ) + len ( batched_events ) - 1 if new_length >= cls . max_hec_event_length : if batched_events : new_events . append ( \" \\n \" . join ( batched_events )) del batched_events [:] size = 0 batched_events . append ( event ) size = size + len ( event ) if batched_events : new_events . append ( \" \\n \" . join ( batched_events )) return new_events XMLEvent ( Event ) \u00b6 XML event. format_events ( events ) classmethod \u00b6 Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required Returns: Type Description List of formatted events string, example : [ ' <stream> <event stanza= \"test_scheme://test\" unbroken= \"1\" > <time> 1459919070.994 </time> <index> main </index> <host> localhost </host> <source> test </source> <sourcetype> test </sourcetype> <data> {\"kk\": [1, 2, 3]} </data> <done /> </event> <event stanza= \"test_scheme://test\" unbroken= \"1\" > <time> 1459919082.961 </time> <index> main </index> <host> localhost </host> <source> test </source> <sourcetype> test </sourcetype> <data> {\"kk\": [3, 2, 3]} </data> <done /> </event> </stream> ' ] Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. Returns: List of formatted events string, example:: [ '<stream> <event stanza=\"test_scheme://test\" unbroken=\"1\"> <time>1459919070.994</time> <index>main</index> <host>localhost</host> <source>test</source> <sourcetype>test</sourcetype> <data>{\"kk\": [1, 2, 3]}</data> <done /> </event> <event stanza=\"test_scheme://test\" unbroken=\"1\"> <time>1459919082.961</time> <index>main</index> <host>localhost</host> <source>test</source> <sourcetype>test</sourcetype> <data>{\"kk\": [3, 2, 3]}</data> <done /> </event> </stream>' ] \"\"\" stream = ET . Element ( \"stream\" ) for event in events : stream . append ( event . _to_xml ()) return [ defused_et . tostring ( stream , encoding = \"utf-8\" , method = \"xml\" ) . decode ( \"utf-8\" ) ]","title":"event.py"},{"location":"modular_input/event/#solnlib.modular_input.event.__all__","text":"","title":"__all__"},{"location":"modular_input/event/#solnlib.modular_input.event.Event","text":"Base class of modular input event.","title":"Event"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.__init__","text":"Modular input event. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. False done bool (optional) The last unbroken event, default is False. False Examples: >>> event = Event ( >>> data = 'This is a test data.' , >>> time = 1372274622.493 , >>> index = 'main' , >>> host = 'localhost' , >>> source = 'Splunk' , >>> sourcetype = 'misc' , >>> fields = { 'Cloud' : 'AWS' , 'region' : 'us-west-1' }, >>> stanza = 'test_scheme://test' , >>> unbroken = True , >>> done = True ) Source code in solnlib/modular_input/event.py def __init__ ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ): \"\"\"Modular input event. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. done: (optional) The last unbroken event, default is False. Examples: >>> event = Event( >>> data='This is a test data.', >>> time=1372274622.493, >>> index='main', >>> host='localhost', >>> source='Splunk', >>> sourcetype='misc', >>> fields= {'Cloud':'AWS','region': 'us-west-1'}, >>> stanza='test_scheme://test', >>> unbroken=True, >>> done=True) \"\"\" self . _data = data self . _time = \" %.3f \" % time if time else None self . _index = index self . _host = host self . _source = source self . _sourcetype = sourcetype if fields : self . _fields = fields self . _stanza = stanza if not unbroken and done : raise EventException ( 'Invalid combination of \"unbroken\" and \"done\".' ) self . _unbroken = unbroken self . _done = done","title":"__init__()"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.__str__","text":"Source code in solnlib/modular_input/event.py def __str__ ( self ): event = { \"data\" : self . _data , \"time\" : float ( self . _time ) if self . _time else self . _time , \"index\" : self . _index , \"host\" : self . _host , \"source\" : self . _source , \"sourcetype\" : self . _sourcetype , \"stanza\" : self . _stanza , \"unbroken\" : self . _unbroken , \"done\" : self . _done , } if hasattr ( self , \"_fields\" ): event [ \"fields\" ] = self . _fields return json . dumps ( event )","title":"__str__()"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.format_events","text":"Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required Returns: Type Description List List of formatted events string. Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. Returns: List of formatted events string. \"\"\" raise EventException ( 'Unimplemented \"format_events\".' )","title":"format_events()"},{"location":"modular_input/event/#solnlib.modular_input.event.EventException","text":"","title":"EventException"},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent","text":"HEC event.","title":"HECEvent"},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent.max_hec_event_length","text":"","title":"max_hec_event_length"},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent.format_events","text":"Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required event_field str Event field. 'event' Returns: Type Description List of formatted events string, example : [ '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\n {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}', '...' ] Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List , event_field : str = \"event\" ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. event_field: Event field. Returns: List of formatted events string, example:: [ '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\\\n {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}', '...' ] \"\"\" size = 0 new_events , batched_events = [], [] events = [ event . _to_hec ( event_field ) for event in events ] for event in events : new_length = size + len ( event ) + len ( batched_events ) - 1 if new_length >= cls . max_hec_event_length : if batched_events : new_events . append ( \" \\n \" . join ( batched_events )) del batched_events [:] size = 0 batched_events . append ( event ) size = size + len ( event ) if batched_events : new_events . append ( \" \\n \" . join ( batched_events )) return new_events","title":"format_events()"},{"location":"modular_input/event/#solnlib.modular_input.event.XMLEvent","text":"XML event.","title":"XMLEvent"},{"location":"modular_input/event/#solnlib.modular_input.event.XMLEvent.format_events","text":"Format events to list of string. Parameters: Name Type Description Default events List List of events to format. required Returns: Type Description List of formatted events string, example : [ ' <stream> <event stanza= \"test_scheme://test\" unbroken= \"1\" > <time> 1459919070.994 </time> <index> main </index> <host> localhost </host> <source> test </source> <sourcetype> test </sourcetype> <data> {\"kk\": [1, 2, 3]} </data> <done /> </event> <event stanza= \"test_scheme://test\" unbroken= \"1\" > <time> 1459919082.961 </time> <index> main </index> <host> localhost </host> <source> test </source> <sourcetype> test </sourcetype> <data> {\"kk\": [3, 2, 3]} </data> <done /> </event> </stream> ' ] Source code in solnlib/modular_input/event.py @classmethod def format_events ( cls , events : List ) -> List : \"\"\"Format events to list of string. Arguments: events: List of events to format. Returns: List of formatted events string, example:: [ '<stream> <event stanza=\"test_scheme://test\" unbroken=\"1\"> <time>1459919070.994</time> <index>main</index> <host>localhost</host> <source>test</source> <sourcetype>test</sourcetype> <data>{\"kk\": [1, 2, 3]}</data> <done /> </event> <event stanza=\"test_scheme://test\" unbroken=\"1\"> <time>1459919082.961</time> <index>main</index> <host>localhost</host> <source>test</source> <sourcetype>test</sourcetype> <data>{\"kk\": [3, 2, 3]}</data> <done /> </event> </stream>' ] \"\"\" stream = ET . Element ( \"stream\" ) for event in events : stream . append ( event . _to_xml ()) return [ defused_et . tostring ( stream , encoding = \"utf-8\" , method = \"xml\" ) . decode ( \"utf-8\" ) ]","title":"format_events()"},{"location":"modular_input/event_writer/","text":"This module provides two kinds of event writers (ClassicEventWriter, HECEventWriter) to write Splunk modular input events. __all__ special \u00b6 ClassicEventWriter ( EventWriter ) \u00b6 Classic event writer. Use sys.stdout as the output. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . ClassicEventWriter () >>> ew . write_events ([ event1 , event2 ]) description \u00b6 __init__ ( self , lock = None ) special \u00b6 Initializes ClassicEventWriter. Parameters: Name Type Description Default lock Union[<built-in function allocate_lock>, <bound method BaseContext.Lock of <multiprocessing.context.DefaultContext object at 0x7f23075b6450>>] (optional) lock to exclusively access stdout. by default, it is None and it will use threading safe lock. if user would like to make the lock multiple-process safe, user should pass in multiprocessing.Lock() instead None Source code in solnlib/modular_input/event_writer.py def __init__ ( self , lock : Union [ threading . Lock , multiprocessing . Lock ] = None ): \"\"\"Initializes ClassicEventWriter. Arguments: lock: (optional) lock to exclusively access stdout. by default, it is None and it will use threading safe lock. if user would like to make the lock multiple-process safe, user should pass in multiprocessing.Lock() instead \"\"\" if lock is None : self . _lock = threading . Lock () else : self . _lock = lock create_event ( self , data , time = None , index = None , host = None , source = None , sourcetype = None , fields = None , stanza = None , unbroken = False , done = False ) \u00b6 Create a new XMLEvent object. Source code in solnlib/modular_input/event_writer.py def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ): \"\"\"Create a new XMLEvent object.\"\"\" return XMLEvent ( data , time = time , index = index , host = host , source = source , sourcetype = sourcetype , stanza = stanza , unbroken = unbroken , done = done , ) write_events ( self , events ) \u00b6 Write events. Parameters: Name Type Description Default events List of events to write. required Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . EventWriter ( ... ) >>> ew . write_events ([ event1 , event2 ]) Source code in solnlib/modular_input/event_writer.py def write_events ( self , events ): if not events : return stdout = sys . stdout data = \"\" . join ([ event for event in XMLEvent . format_events ( events )]) with self . _lock : stdout . write ( data ) stdout . flush () EventWriter \u00b6 Base class of event writer. description \u00b6 create_event ( self , data , time = None , index = None , host = None , source = None , sourcetype = None , fields = None , stanza = None , unbroken = False , done = False ) \u00b6 Create a new event. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False done bool (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False Examples: >>> ew = event_writer . HECEventWriter ( ... ) >>> event = ew . create_event ( >>> data = 'This is a test data.' , >>> time = ' %.3f ' % 1372274622.493 , >>> index = 'main' , >>> host = 'localhost' , >>> source = 'Splunk' , >>> sourcetype = 'misc' , >>> fields = { 'accountid' : '603514901691' , 'Cloud' : u 'AWS' }, >>> stanza = 'test_scheme://test' , >>> unbroken = True , >>> done = True ) Source code in solnlib/modular_input/event_writer.py @abstractmethod def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ) -> Union [ XMLEvent , HECEvent ]: \"\"\"Create a new event. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. done: (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. Examples: >>> ew = event_writer.HECEventWriter(...) >>> event = ew.create_event( >>> data='This is a test data.', >>> time='%.3f' % 1372274622.493, >>> index='main', >>> host='localhost', >>> source='Splunk', >>> sourcetype='misc', >>> fields={'accountid': '603514901691', 'Cloud': u'AWS'}, >>> stanza='test_scheme://test', >>> unbroken=True, >>> done=True) \"\"\" pass write_events ( self , events ) \u00b6 Write events. Parameters: Name Type Description Default events List List of events to write. required Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . EventWriter ( ... ) >>> ew . write_events ([ event1 , event2 ]) Source code in solnlib/modular_input/event_writer.py @abstractmethod def write_events ( self , events : List ): \"\"\"Write events. Arguments: events: List of events to write. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer.EventWriter(...) >>> ew.write_events([event1, event2]) \"\"\" pass HECEventWriter ( EventWriter ) \u00b6 HEC event writer. Use Splunk HEC as the output. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . HECEventWriter ( hec_input_name , session_key ) >>> ew . write_events ([ event1 , event2 ]) HTTP_EVENT_COLLECTOR_ENDPOINT \u00b6 HTTP_INPUT_CONFIG_ENDPOINT \u00b6 SERVICE_UNAVAILABLE \u00b6 TOO_MANY_REQUESTS \u00b6 WRITE_EVENT_RETRIES \u00b6 description \u00b6 headers \u00b6 __init__ ( self , hec_input_name , session_key , scheme = None , host = None , port = None , hec_uri = None , hec_token = None , logger = None , ** context ) special \u00b6 Initializes HECEventWriter. Parameters: Name Type Description Default hec_input_name str Splunk HEC input name. required session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None hec_uri str (optional) If hec_uri and hec_token are provided, they will higher precedence than hec_input_name. None hec_token str (optional) HEC token. None logger Logger Logger object. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/modular_input/event_writer.py def __init__ ( self , hec_input_name : str , session_key : str , scheme : str = None , host : str = None , port : int = None , hec_uri : str = None , hec_token : str = None , logger : logging . Logger = None , ** context : dict ): \"\"\"Initializes HECEventWriter. Arguments: hec_input_name: Splunk HEC input name. session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. hec_uri: (optional) If hec_uri and hec_token are provided, they will higher precedence than hec_input_name. hec_token: (optional) HEC token. logger: Logger object. context: Other configurations for Splunk rest client. \"\"\" super () . __init__ () self . _session_key = session_key if logger : self . logger = logger else : self . logger = logging if not all ([ scheme , host , port ]): scheme , host , port = get_splunkd_access_info () if hec_uri and hec_token : scheme , host , hec_port = utils . extract_http_scheme_host_port ( hec_uri ) else : hec_port , hec_token = self . _get_hec_config ( hec_input_name , session_key , scheme , host , port , ** context ) if not context . get ( \"pool_connections\" ): context [ \"pool_connections\" ] = 10 if not context . get ( \"pool_maxsize\" ): context [ \"pool_maxsize\" ] = 10 self . _rest_client = rest_client . SplunkRestClient ( hec_token , app = \"-\" , scheme = scheme , host = host , port = hec_port , ** context ) create_event ( self , data , time = None , index = None , host = None , source = None , sourcetype = None , fields = None , stanza = None , unbroken = False , done = False ) \u00b6 Create a new HECEvent object. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False done bool (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False Returns: Type Description HECEvent Created HECEvent. Source code in solnlib/modular_input/event_writer.py def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ) -> HECEvent : \"\"\"Create a new HECEvent object. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. done: (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. Returns: Created HECEvent. \"\"\" return HECEvent ( data , time = time , index = index , host = host , source = source , sourcetype = sourcetype , fields = fields , ) create_from_input ( hec_input_name , splunkd_uri , session_key , ** context ) staticmethod \u00b6 Given HEC input stanza name, splunkd URI and splunkd session key, create HECEventWriter object. HEC URI and token etc will be discovered from HEC input stanza. When hitting HEC event limit, the underlying code will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Parameters: Name Type Description Default hec_input_name str Splunk HEC input name. required splunkd_uri str Splunkd URI, like https://localhost:8089 required session_key str Splunkd access token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_input ( hec_input_name : str , splunkd_uri : str , session_key : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given HEC input stanza name, splunkd URI and splunkd session key, create HECEventWriter object. HEC URI and token etc will be discovered from HEC input stanza. When hitting HEC event limit, the underlying code will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Arguments: hec_input_name: Splunk HEC input name. splunkd_uri: Splunkd URI, like https://localhost:8089 session_key: Splunkd access token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( splunkd_uri ) return HECEventWriter ( hec_input_name , session_key , scheme , host , port , ** context ) create_from_token ( hec_uri , hec_token , ** context ) staticmethod \u00b6 Given HEC URI and HEC token, create HECEventWriter object. This function simplifies the standalone mode HECEventWriter usage (not in a modinput). Parameters: Name Type Description Default hec_uri str HTTP Event Collector URI, like https://localhost:8088. required hec_token str HTTP Event Collector token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_token ( hec_uri : str , hec_token : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given HEC URI and HEC token, create HECEventWriter object. This function simplifies the standalone mode HECEventWriter usage (not in a modinput). Arguments: hec_uri: HTTP Event Collector URI, like https://localhost:8088. hec_token: HTTP Event Collector token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" return HECEventWriter ( None , None , None , None , None , hec_uri = hec_uri , hec_token = hec_token , ** context ) create_from_token_with_session_key ( splunkd_uri , session_key , hec_uri , hec_token , ** context ) staticmethod \u00b6 Given Splunkd URI, Splunkd session key, HEC URI and HEC token, create HECEventWriter object. When hitting HEC event limit, the event writer will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Parameters: Name Type Description Default splunkd_uri str Splunkd URI, like https://localhost:8089. required session_key str Splunkd access token. required hec_uri str Http Event Collector URI, like https://localhost:8088. required hec_token str Http Event Collector token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_token_with_session_key ( splunkd_uri : str , session_key : str , hec_uri : str , hec_token : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given Splunkd URI, Splunkd session key, HEC URI and HEC token, create HECEventWriter object. When hitting HEC event limit, the event writer will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Arguments: splunkd_uri: Splunkd URI, like https://localhost:8089. session_key: Splunkd access token. hec_uri: Http Event Collector URI, like https://localhost:8088. hec_token: Http Event Collector token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( splunkd_uri ) return HECEventWriter ( None , session_key , scheme , host , port , hec_uri = hec_uri , hec_token = hec_token , ** context ) write_events ( self , events , retries = 5 , event_field = 'event' ) \u00b6 Write events to index in bulk. Parameters: Name Type Description Default events List List of events. required retries int Number of retries for writing events to index. 5 event_field str Event field. 'event' Source code in solnlib/modular_input/event_writer.py def write_events ( self , events : List , retries : int = WRITE_EVENT_RETRIES , event_field : str = \"event\" , ): \"\"\"Write events to index in bulk. Arguments: events: List of events. retries: Number of retries for writing events to index. event_field: Event field. \"\"\" if not events : return last_ex = None for event in HECEvent . format_events ( events , event_field ): for i in range ( retries ): try : self . _rest_client . post ( self . HTTP_EVENT_COLLECTOR_ENDPOINT , body = event . encode ( 'utf-8' ), headers = self . headers , ) except binding . HTTPError as e : self . logger . warn ( \"Write events through HEC failed. Status= %s \" , e . status ) last_ex = e if e . status in [ self . TOO_MANY_REQUESTS , self . SERVICE_UNAVAILABLE ]: # wait time for n retries: 10, 20, 40, 80, 80, 80, 80, .... sleep_time = min ((( 2 ** ( i + 1 )) * 5 ), 80 ) if i < retries - 1 : random_millisecond = randint ( 0 , 1000 ) / 1000.0 time . sleep ( sleep_time + random_millisecond ) else : raise last_ex else : break else : # When failed after retry, we reraise the exception # to exit the function to let client handle this situation self . logger . error ( \"Write events through HEC failed: %s . status= %s \" , traceback . format_exc (), last_ex . status , ) raise last_ex","title":"event_writer.py"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.__all__","text":"","title":"__all__"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter","text":"Classic event writer. Use sys.stdout as the output. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . ClassicEventWriter () >>> ew . write_events ([ event1 , event2 ])","title":"ClassicEventWriter"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.description","text":"","title":"description"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.__init__","text":"Initializes ClassicEventWriter. Parameters: Name Type Description Default lock Union[<built-in function allocate_lock>, <bound method BaseContext.Lock of <multiprocessing.context.DefaultContext object at 0x7f23075b6450>>] (optional) lock to exclusively access stdout. by default, it is None and it will use threading safe lock. if user would like to make the lock multiple-process safe, user should pass in multiprocessing.Lock() instead None Source code in solnlib/modular_input/event_writer.py def __init__ ( self , lock : Union [ threading . Lock , multiprocessing . Lock ] = None ): \"\"\"Initializes ClassicEventWriter. Arguments: lock: (optional) lock to exclusively access stdout. by default, it is None and it will use threading safe lock. if user would like to make the lock multiple-process safe, user should pass in multiprocessing.Lock() instead \"\"\" if lock is None : self . _lock = threading . Lock () else : self . _lock = lock","title":"__init__()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.create_event","text":"Create a new XMLEvent object. Source code in solnlib/modular_input/event_writer.py def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ): \"\"\"Create a new XMLEvent object.\"\"\" return XMLEvent ( data , time = time , index = index , host = host , source = source , sourcetype = sourcetype , stanza = stanza , unbroken = unbroken , done = done , )","title":"create_event()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.write_events","text":"Write events. Parameters: Name Type Description Default events List of events to write. required Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . EventWriter ( ... ) >>> ew . write_events ([ event1 , event2 ]) Source code in solnlib/modular_input/event_writer.py def write_events ( self , events ): if not events : return stdout = sys . stdout data = \"\" . join ([ event for event in XMLEvent . format_events ( events )]) with self . _lock : stdout . write ( data ) stdout . flush ()","title":"write_events()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter","text":"Base class of event writer.","title":"EventWriter"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.description","text":"","title":"description"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.create_event","text":"Create a new event. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False done bool (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False Examples: >>> ew = event_writer . HECEventWriter ( ... ) >>> event = ew . create_event ( >>> data = 'This is a test data.' , >>> time = ' %.3f ' % 1372274622.493 , >>> index = 'main' , >>> host = 'localhost' , >>> source = 'Splunk' , >>> sourcetype = 'misc' , >>> fields = { 'accountid' : '603514901691' , 'Cloud' : u 'AWS' }, >>> stanza = 'test_scheme://test' , >>> unbroken = True , >>> done = True ) Source code in solnlib/modular_input/event_writer.py @abstractmethod def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ) -> Union [ XMLEvent , HECEvent ]: \"\"\"Create a new event. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. done: (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. Examples: >>> ew = event_writer.HECEventWriter(...) >>> event = ew.create_event( >>> data='This is a test data.', >>> time='%.3f' % 1372274622.493, >>> index='main', >>> host='localhost', >>> source='Splunk', >>> sourcetype='misc', >>> fields={'accountid': '603514901691', 'Cloud': u'AWS'}, >>> stanza='test_scheme://test', >>> unbroken=True, >>> done=True) \"\"\" pass","title":"create_event()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.write_events","text":"Write events. Parameters: Name Type Description Default events List List of events to write. required Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . EventWriter ( ... ) >>> ew . write_events ([ event1 , event2 ]) Source code in solnlib/modular_input/event_writer.py @abstractmethod def write_events ( self , events : List ): \"\"\"Write events. Arguments: events: List of events to write. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer.EventWriter(...) >>> ew.write_events([event1, event2]) \"\"\" pass","title":"write_events()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter","text":"HEC event writer. Use Splunk HEC as the output. Examples: >>> from solnlib.modular_input import event_writer >>> ew = event_writer . HECEventWriter ( hec_input_name , session_key ) >>> ew . write_events ([ event1 , event2 ])","title":"HECEventWriter"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.HTTP_EVENT_COLLECTOR_ENDPOINT","text":"","title":"HTTP_EVENT_COLLECTOR_ENDPOINT"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.HTTP_INPUT_CONFIG_ENDPOINT","text":"","title":"HTTP_INPUT_CONFIG_ENDPOINT"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.SERVICE_UNAVAILABLE","text":"","title":"SERVICE_UNAVAILABLE"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.TOO_MANY_REQUESTS","text":"","title":"TOO_MANY_REQUESTS"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.WRITE_EVENT_RETRIES","text":"","title":"WRITE_EVENT_RETRIES"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.description","text":"","title":"description"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.headers","text":"","title":"headers"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.__init__","text":"Initializes HECEventWriter. Parameters: Name Type Description Default hec_input_name str Splunk HEC input name. required session_key str Splunk access token. required scheme str (optional) The access scheme, default is None. None host str (optional) The host name, default is None. None port int (optional) The port number, default is None. None hec_uri str (optional) If hec_uri and hec_token are provided, they will higher precedence than hec_input_name. None hec_token str (optional) HEC token. None logger Logger Logger object. None context dict Other configurations for Splunk rest client. {} Source code in solnlib/modular_input/event_writer.py def __init__ ( self , hec_input_name : str , session_key : str , scheme : str = None , host : str = None , port : int = None , hec_uri : str = None , hec_token : str = None , logger : logging . Logger = None , ** context : dict ): \"\"\"Initializes HECEventWriter. Arguments: hec_input_name: Splunk HEC input name. session_key: Splunk access token. scheme: (optional) The access scheme, default is None. host: (optional) The host name, default is None. port: (optional) The port number, default is None. hec_uri: (optional) If hec_uri and hec_token are provided, they will higher precedence than hec_input_name. hec_token: (optional) HEC token. logger: Logger object. context: Other configurations for Splunk rest client. \"\"\" super () . __init__ () self . _session_key = session_key if logger : self . logger = logger else : self . logger = logging if not all ([ scheme , host , port ]): scheme , host , port = get_splunkd_access_info () if hec_uri and hec_token : scheme , host , hec_port = utils . extract_http_scheme_host_port ( hec_uri ) else : hec_port , hec_token = self . _get_hec_config ( hec_input_name , session_key , scheme , host , port , ** context ) if not context . get ( \"pool_connections\" ): context [ \"pool_connections\" ] = 10 if not context . get ( \"pool_maxsize\" ): context [ \"pool_maxsize\" ] = 10 self . _rest_client = rest_client . SplunkRestClient ( hec_token , app = \"-\" , scheme = scheme , host = host , port = hec_port , ** context )","title":"__init__()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_event","text":"Create a new HECEvent object. Parameters: Name Type Description Default data dict Event data. required time float (optional) Event timestamp, default is None. None index str (optional) The index event will be written to, default is None. None host str (optional) Event host, default is None. None source str (optional) Event source, default is None. None sourcetype str (optional) Event sourcetype, default is None. None fields dict (optional) Event fields, default is None. None stanza str (optional) Event stanza name, default is None. None unbroken bool (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False done bool (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. False Returns: Type Description HECEvent Created HECEvent. Source code in solnlib/modular_input/event_writer.py def create_event ( self , data : dict , time : float = None , index : str = None , host : str = None , source : str = None , sourcetype : str = None , fields : dict = None , stanza : str = None , unbroken : bool = False , done : bool = False , ) -> HECEvent : \"\"\"Create a new HECEvent object. Arguments: data: Event data. time: (optional) Event timestamp, default is None. index: (optional) The index event will be written to, default is None. host: (optional) Event host, default is None. source: (optional) Event source, default is None. sourcetype: (optional) Event sourcetype, default is None. fields: (optional) Event fields, default is None. stanza: (optional) Event stanza name, default is None. unbroken: (optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. done: (optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter. Returns: Created HECEvent. \"\"\" return HECEvent ( data , time = time , index = index , host = host , source = source , sourcetype = sourcetype , fields = fields , )","title":"create_event()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_input","text":"Given HEC input stanza name, splunkd URI and splunkd session key, create HECEventWriter object. HEC URI and token etc will be discovered from HEC input stanza. When hitting HEC event limit, the underlying code will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Parameters: Name Type Description Default hec_input_name str Splunk HEC input name. required splunkd_uri str Splunkd URI, like https://localhost:8089 required session_key str Splunkd access token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_input ( hec_input_name : str , splunkd_uri : str , session_key : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given HEC input stanza name, splunkd URI and splunkd session key, create HECEventWriter object. HEC URI and token etc will be discovered from HEC input stanza. When hitting HEC event limit, the underlying code will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Arguments: hec_input_name: Splunk HEC input name. splunkd_uri: Splunkd URI, like https://localhost:8089 session_key: Splunkd access token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( splunkd_uri ) return HECEventWriter ( hec_input_name , session_key , scheme , host , port , ** context )","title":"create_from_input()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_token","text":"Given HEC URI and HEC token, create HECEventWriter object. This function simplifies the standalone mode HECEventWriter usage (not in a modinput). Parameters: Name Type Description Default hec_uri str HTTP Event Collector URI, like https://localhost:8088. required hec_token str HTTP Event Collector token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_token ( hec_uri : str , hec_token : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given HEC URI and HEC token, create HECEventWriter object. This function simplifies the standalone mode HECEventWriter usage (not in a modinput). Arguments: hec_uri: HTTP Event Collector URI, like https://localhost:8088. hec_token: HTTP Event Collector token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" return HECEventWriter ( None , None , None , None , None , hec_uri = hec_uri , hec_token = hec_token , ** context )","title":"create_from_token()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_token_with_session_key","text":"Given Splunkd URI, Splunkd session key, HEC URI and HEC token, create HECEventWriter object. When hitting HEC event limit, the event writer will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Parameters: Name Type Description Default splunkd_uri str Splunkd URI, like https://localhost:8089. required session_key str Splunkd access token. required hec_uri str Http Event Collector URI, like https://localhost:8088. required hec_token str Http Event Collector token. required context dict Other configurations. {} Returns: Type Description HECEventWriter Created HECEventWriter. Source code in solnlib/modular_input/event_writer.py @staticmethod def create_from_token_with_session_key ( splunkd_uri : str , session_key : str , hec_uri : str , hec_token : str , ** context : dict ) -> \"HECEventWriter\" : \"\"\"Given Splunkd URI, Splunkd session key, HEC URI and HEC token, create HECEventWriter object. When hitting HEC event limit, the event writer will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key. Arguments: splunkd_uri: Splunkd URI, like https://localhost:8089. session_key: Splunkd access token. hec_uri: Http Event Collector URI, like https://localhost:8088. hec_token: Http Event Collector token. context: Other configurations. Returns: Created HECEventWriter. \"\"\" scheme , host , port = utils . extract_http_scheme_host_port ( splunkd_uri ) return HECEventWriter ( None , session_key , scheme , host , port , hec_uri = hec_uri , hec_token = hec_token , ** context )","title":"create_from_token_with_session_key()"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.write_events","text":"Write events to index in bulk. Parameters: Name Type Description Default events List List of events. required retries int Number of retries for writing events to index. 5 event_field str Event field. 'event' Source code in solnlib/modular_input/event_writer.py def write_events ( self , events : List , retries : int = WRITE_EVENT_RETRIES , event_field : str = \"event\" , ): \"\"\"Write events to index in bulk. Arguments: events: List of events. retries: Number of retries for writing events to index. event_field: Event field. \"\"\" if not events : return last_ex = None for event in HECEvent . format_events ( events , event_field ): for i in range ( retries ): try : self . _rest_client . post ( self . HTTP_EVENT_COLLECTOR_ENDPOINT , body = event . encode ( 'utf-8' ), headers = self . headers , ) except binding . HTTPError as e : self . logger . warn ( \"Write events through HEC failed. Status= %s \" , e . status ) last_ex = e if e . status in [ self . TOO_MANY_REQUESTS , self . SERVICE_UNAVAILABLE ]: # wait time for n retries: 10, 20, 40, 80, 80, 80, 80, .... sleep_time = min ((( 2 ** ( i + 1 )) * 5 ), 80 ) if i < retries - 1 : random_millisecond = randint ( 0 , 1000 ) / 1000.0 time . sleep ( sleep_time + random_millisecond ) else : raise last_ex else : break else : # When failed after retry, we reraise the exception # to exit the function to let client handle this situation self . logger . error ( \"Write events through HEC failed: %s . status= %s \" , traceback . format_exc (), last_ex . status , ) raise last_ex","title":"write_events()"},{"location":"modular_input/modular_input/","text":"This module provides a base class of Splunk modular input. __all__ special \u00b6 ModularInput \u00b6 Base class of Splunk modular input. It\u2019s a base modular input, it should be inherited by sub modular input. For sub modular input, properties: \u2018app\u2019, \u2018name\u2019, \u2018title\u2019 and \u2018description\u2019 must be overriden, also there are some other optional properties can be overriden like: \u2018use_external_validation\u2019, \u2018use_single_instance\u2019, \u2018use_kvstore_checkpointer\u2019 and \u2018use_hec_event_writer\u2019. Notes: If you set \u2018KVStoreCheckpointer\u2019 or \u2018use_hec_event_writer\u2019 to True, you must override the corresponding \u2018kvstore_checkpointer_collection_name\u2019 and \u2018hec_input_name\u2019. Examples: >>> Class TestModularInput ( ModularInput ): >>> app = 'TestApp' >>> name = 'test_modular_input' >>> title = 'Test modular input' >>> description = 'This is a test modular input' >>> use_external_validation = True >>> use_single_instance = False >>> use_kvstore_checkpointer = True >>> kvstore_checkpointer_collection_name = 'TestCheckpoint' >>> use_hec_event_writer = True >>> hec_input_name = 'TestEventWriter' >>> >>> def extra_arguments ( self ): >>> ... .. . >>> >>> def do_validation ( self , parameters ): >>> ... .. . >>> >>> def do_run ( self , inputs ): >>> ... .. . >>> >>> if __name__ == '__main__' : >>> md = TestModularInput () >>> md . execute () app \u00b6 checkpointer : Checkpointer property readonly \u00b6 Get checkpointer object. The checkpointer returned depends on use_kvstore_checkpointer flag, if use_kvstore_checkpointer is true will return an KVStoreCheckpointer object else an FileCheckpointer object. Returns: Type Description Checkpointer A checkpointer object. description \u00b6 event_writer : EventWriter property readonly \u00b6 Get event writer object. The event writer returned depends on use_hec_event_writer flag, if use_hec_event_writer is true will return an HECEventWriter object else an ClassicEventWriter object. Returns: Type Description EventWriter Event writer object. hec_input_name \u00b6 kvstore_checkpointer_collection_name \u00b6 name \u00b6 title \u00b6 use_external_validation \u00b6 use_hec_event_writer \u00b6 use_kvstore_checkpointer \u00b6 use_single_instance \u00b6 __init__ ( self ) special \u00b6 Source code in solnlib/modular_input/modular_input.py def __init__ ( self ): # Validate properties self . _validate_properties () # Modular input state self . should_exit = False # Metadata self . server_host_name = None self . server_uri = None self . server_scheme = None self . server_host = None self . server_port = None self . session_key = None # Modular input config name self . config_name = None # Checkpoint dir self . _checkpoint_dir = None # Checkpointer self . _checkpointer = None # Orphan process monitor self . _orphan_monitor = None # Event writer self . _event_writer = None do_run ( self , inputs ) \u00b6 Runs this modular input. Parameters: Name Type Description Default inputs dict Command line arguments passed to this modular input. For single instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } For multiple instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } required Source code in solnlib/modular_input/modular_input.py @abstractmethod def do_run ( self , inputs : dict ): \"\"\"Runs this modular input. Arguments: inputs: Command line arguments passed to this modular input. For single instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } For multiple instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } \"\"\" pass do_validation ( self , parameters ) \u00b6 Handles external validation for modular input kinds. When Splunk calls a modular input script in validation mode, it will pass in an XML document giving information about the Splunk instance (so you can call back into it if needed) and the name and parameters of the proposed input. If this function does not throw an exception, the validation is assumed to succeed. Otherwise any errors thrown will be turned into a string and logged back to Splunk. Parameters: Name Type Description Default parameters The parameters of input passed by splunkd. required Exceptions: Type Description Exception If validation is failed. Source code in solnlib/modular_input/modular_input.py def do_validation ( self , parameters ): \"\"\"Handles external validation for modular input kinds. When Splunk calls a modular input script in validation mode, it will pass in an XML document giving information about the Splunk instance (so you can call back into it if needed) and the name and parameters of the proposed input. If this function does not throw an exception, the validation is assumed to succeed. Otherwise any errors thrown will be turned into a string and logged back to Splunk. Arguments: parameters: The parameters of input passed by splunkd. Raises: Exception: If validation is failed. \"\"\" pass execute ( self ) \u00b6 Modular input entry. Examples: >>> Class TestModularInput ( ModularInput ): >>> ... .. . >>> >>> if __name__ == '__main__' : >>> md = TestModularInput () >>> md . execute () Source code in solnlib/modular_input/modular_input.py def execute ( self ): \"\"\"Modular input entry. Examples: >>> Class TestModularInput(ModularInput): >>> ... .. . >>> >>> if __name__ == '__main__': >>> md = TestModularInput() >>> md.execute() \"\"\" if len ( sys . argv ) == 1 : try : input_definition = self . get_input_definition () self . _update_metadata ( input_definition [ \"metadata\" ]) if self . use_single_instance : self . config_name = self . name else : self . config_name = list ( input_definition [ \"inputs\" ] . keys ())[ 0 ] self . do_run ( input_definition [ \"inputs\" ]) logging . info ( \"Modular input: %s exit normally.\" , self . name ) return 0 except Exception as e : logging . error ( \"Modular input: %s exit with exception: %s .\" , self . name , traceback . format_exc (), ) return 1 finally : # Stop orphan monitor if any if self . _orphan_monitor : self . _orphan_monitor . stop () elif str ( sys . argv [ 1 ]) . lower () == \"--scheme\" : sys . stdout . write ( self . _do_scheme ()) sys . stdout . flush () return 0 elif sys . argv [ 1 ] . lower () == \"--validate-arguments\" : try : validation_definition = self . get_validation_definition () self . _update_metadata ( validation_definition [ \"metadata\" ]) self . do_validation ( validation_definition [ \"parameters\" ]) return 0 except Exception as e : logging . error ( \"Modular input: %s validate arguments with exception: %s .\" , self . name , traceback . format_exc (), ) root = ET . Element ( \"error\" ) ET . SubElement ( root , \"message\" ) . text = str ( e ) sys . stderr . write ( defused_et . tostring ( root )) sys . stderr . flush () return 1 else : logging . error ( 'Modular input: %s run with invalid arguments: \" %s \".' , self . name , \" \" . join ( sys . argv [ 1 :]), ) return 1 extra_arguments ( self ) \u00b6 Extra arguments for modular input. Default implementation is returning an empty list. Returns: Type Description List of arguments like : [ { 'name': 'arg1', 'title': 'arg1 title', 'description': 'arg1 description', 'validation': 'arg1 validation statement', 'data_type': Argument.data_type_string, 'required_on_edit': False, 'required_on_create': False }, {...}, {...} ] Source code in solnlib/modular_input/modular_input.py def extra_arguments ( self ) -> List : \"\"\"Extra arguments for modular input. Default implementation is returning an empty list. Returns: List of arguments like:: [ { 'name': 'arg1', 'title': 'arg1 title', 'description': 'arg1 description', 'validation': 'arg1 validation statement', 'data_type': Argument.data_type_string, 'required_on_edit': False, 'required_on_create': False }, {...}, {...} ] \"\"\" return [] get_input_definition ( self ) \u00b6 Get input definition. This method can be overwritten to get input definition from other input instead stdin . Returns: Type Description A dict object must contains `metadata` and `inputs` : example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, inputs: { 'stanza1': {'arg1': value1, 'arg2': value2}, 'stanza2': {'arg1': value1, 'arg2': value2} } } Source code in solnlib/modular_input/modular_input.py def get_input_definition ( self ) -> dict : \"\"\"Get input definition. This method can be overwritten to get input definition from other input instead `stdin`. Returns: A dict object must contains `metadata` and `inputs`:: example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, inputs: { 'stanza1': {'arg1': value1, 'arg2': value2}, 'stanza2': {'arg1': value1, 'arg2': value2} } } \"\"\" input_definition = InputDefinition . parse ( sys . stdin ) return { \"metadata\" : input_definition . metadata , \"inputs\" : input_definition . inputs , } get_validation_definition ( self ) \u00b6 Get validation definition. This method can be overwritten to get validation definition from other input instead stdin . Returns: Type Description A dict object must contains `metadata` and `parameters` : example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, parameters: {'args1': value1, 'args2': value2} } Source code in solnlib/modular_input/modular_input.py def get_validation_definition ( self ) -> dict : \"\"\"Get validation definition. This method can be overwritten to get validation definition from other input instead `stdin`. Returns: A dict object must contains `metadata` and `parameters`:: example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, parameters: {'args1': value1, 'args2': value2} } \"\"\" validation_definition = ValidationDefinition . parse ( sys . stdin ) return { \"metadata\" : validation_definition . metadata , \"parameters\" : validation_definition . parameters , } register_orphan_handler ( self , handler , * args ) \u00b6 Register orphan process handler. Parameters: Name Type Description Default handler Callable Teardown signal handler. required args Arguments to the handler. () Examples: >>> mi = ModularInput ( ... ) >>> def orphan_handler ( arg1 , arg2 , ... ): >>> ... >>> mi . register_orphan_handler ( orphan_handler , arg1 , arg2 , ... ) Source code in solnlib/modular_input/modular_input.py def register_orphan_handler ( self , handler : Callable , * args ): \"\"\"Register orphan process handler. Arguments: handler: Teardown signal handler. args: Arguments to the handler. Examples: >>> mi = ModularInput(...) >>> def orphan_handler(arg1, arg2, ...): >>> ... >>> mi.register_orphan_handler(orphan_handler, arg1, arg2, ...) \"\"\" def _orphan_handler (): handler ( * args ) if self . _orphan_monitor is None : self . _orphan_monitor = OrphanProcessMonitor ( _orphan_handler ) self . _orphan_monitor . start () register_teardown_handler ( self , handler , * args ) \u00b6 Register teardown signal handler. Parameters: Name Type Description Default handler Callable Teardown signal handler. required args Arguments to the handler. () Examples: >>> mi = ModularInput ( ... ) >>> def teardown_handler ( arg1 , arg2 , ... ): >>> ... >>> mi . register_teardown_handler ( teardown_handler , arg1 , arg2 , ... ) Source code in solnlib/modular_input/modular_input.py def register_teardown_handler ( self , handler : Callable , * args ): \"\"\"Register teardown signal handler. Arguments: handler: Teardown signal handler. args: Arguments to the handler. Examples: >>> mi = ModularInput(...) >>> def teardown_handler(arg1, arg2, ...): >>> ... >>> mi.register_teardown_handler(teardown_handler, arg1, arg2, ...) \"\"\" def _teardown_handler ( signum , frame ): handler ( * args ) utils . handle_teardown_signals ( _teardown_handler ) ModularInputException ( Exception ) \u00b6 Exception for ModularInput class.","title":"modular_input.py"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.__all__","text":"","title":"__all__"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput","text":"Base class of Splunk modular input. It\u2019s a base modular input, it should be inherited by sub modular input. For sub modular input, properties: \u2018app\u2019, \u2018name\u2019, \u2018title\u2019 and \u2018description\u2019 must be overriden, also there are some other optional properties can be overriden like: \u2018use_external_validation\u2019, \u2018use_single_instance\u2019, \u2018use_kvstore_checkpointer\u2019 and \u2018use_hec_event_writer\u2019. Notes: If you set \u2018KVStoreCheckpointer\u2019 or \u2018use_hec_event_writer\u2019 to True, you must override the corresponding \u2018kvstore_checkpointer_collection_name\u2019 and \u2018hec_input_name\u2019. Examples: >>> Class TestModularInput ( ModularInput ): >>> app = 'TestApp' >>> name = 'test_modular_input' >>> title = 'Test modular input' >>> description = 'This is a test modular input' >>> use_external_validation = True >>> use_single_instance = False >>> use_kvstore_checkpointer = True >>> kvstore_checkpointer_collection_name = 'TestCheckpoint' >>> use_hec_event_writer = True >>> hec_input_name = 'TestEventWriter' >>> >>> def extra_arguments ( self ): >>> ... .. . >>> >>> def do_validation ( self , parameters ): >>> ... .. . >>> >>> def do_run ( self , inputs ): >>> ... .. . >>> >>> if __name__ == '__main__' : >>> md = TestModularInput () >>> md . execute ()","title":"ModularInput"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.app","text":"","title":"app"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.checkpointer","text":"Get checkpointer object. The checkpointer returned depends on use_kvstore_checkpointer flag, if use_kvstore_checkpointer is true will return an KVStoreCheckpointer object else an FileCheckpointer object. Returns: Type Description Checkpointer A checkpointer object.","title":"checkpointer"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.description","text":"","title":"description"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.event_writer","text":"Get event writer object. The event writer returned depends on use_hec_event_writer flag, if use_hec_event_writer is true will return an HECEventWriter object else an ClassicEventWriter object. Returns: Type Description EventWriter Event writer object.","title":"event_writer"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.hec_input_name","text":"","title":"hec_input_name"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.kvstore_checkpointer_collection_name","text":"","title":"kvstore_checkpointer_collection_name"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.name","text":"","title":"name"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.title","text":"","title":"title"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_external_validation","text":"","title":"use_external_validation"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_hec_event_writer","text":"","title":"use_hec_event_writer"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_kvstore_checkpointer","text":"","title":"use_kvstore_checkpointer"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_single_instance","text":"","title":"use_single_instance"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.__init__","text":"Source code in solnlib/modular_input/modular_input.py def __init__ ( self ): # Validate properties self . _validate_properties () # Modular input state self . should_exit = False # Metadata self . server_host_name = None self . server_uri = None self . server_scheme = None self . server_host = None self . server_port = None self . session_key = None # Modular input config name self . config_name = None # Checkpoint dir self . _checkpoint_dir = None # Checkpointer self . _checkpointer = None # Orphan process monitor self . _orphan_monitor = None # Event writer self . _event_writer = None","title":"__init__()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.do_run","text":"Runs this modular input. Parameters: Name Type Description Default inputs dict Command line arguments passed to this modular input. For single instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } For multiple instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } required Source code in solnlib/modular_input/modular_input.py @abstractmethod def do_run ( self , inputs : dict ): \"\"\"Runs this modular input. Arguments: inputs: Command line arguments passed to this modular input. For single instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} 'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } For multiple instance mode, inputs like:: { 'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...} } \"\"\" pass","title":"do_run()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.do_validation","text":"Handles external validation for modular input kinds. When Splunk calls a modular input script in validation mode, it will pass in an XML document giving information about the Splunk instance (so you can call back into it if needed) and the name and parameters of the proposed input. If this function does not throw an exception, the validation is assumed to succeed. Otherwise any errors thrown will be turned into a string and logged back to Splunk. Parameters: Name Type Description Default parameters The parameters of input passed by splunkd. required Exceptions: Type Description Exception If validation is failed. Source code in solnlib/modular_input/modular_input.py def do_validation ( self , parameters ): \"\"\"Handles external validation for modular input kinds. When Splunk calls a modular input script in validation mode, it will pass in an XML document giving information about the Splunk instance (so you can call back into it if needed) and the name and parameters of the proposed input. If this function does not throw an exception, the validation is assumed to succeed. Otherwise any errors thrown will be turned into a string and logged back to Splunk. Arguments: parameters: The parameters of input passed by splunkd. Raises: Exception: If validation is failed. \"\"\" pass","title":"do_validation()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.execute","text":"Modular input entry. Examples: >>> Class TestModularInput ( ModularInput ): >>> ... .. . >>> >>> if __name__ == '__main__' : >>> md = TestModularInput () >>> md . execute () Source code in solnlib/modular_input/modular_input.py def execute ( self ): \"\"\"Modular input entry. Examples: >>> Class TestModularInput(ModularInput): >>> ... .. . >>> >>> if __name__ == '__main__': >>> md = TestModularInput() >>> md.execute() \"\"\" if len ( sys . argv ) == 1 : try : input_definition = self . get_input_definition () self . _update_metadata ( input_definition [ \"metadata\" ]) if self . use_single_instance : self . config_name = self . name else : self . config_name = list ( input_definition [ \"inputs\" ] . keys ())[ 0 ] self . do_run ( input_definition [ \"inputs\" ]) logging . info ( \"Modular input: %s exit normally.\" , self . name ) return 0 except Exception as e : logging . error ( \"Modular input: %s exit with exception: %s .\" , self . name , traceback . format_exc (), ) return 1 finally : # Stop orphan monitor if any if self . _orphan_monitor : self . _orphan_monitor . stop () elif str ( sys . argv [ 1 ]) . lower () == \"--scheme\" : sys . stdout . write ( self . _do_scheme ()) sys . stdout . flush () return 0 elif sys . argv [ 1 ] . lower () == \"--validate-arguments\" : try : validation_definition = self . get_validation_definition () self . _update_metadata ( validation_definition [ \"metadata\" ]) self . do_validation ( validation_definition [ \"parameters\" ]) return 0 except Exception as e : logging . error ( \"Modular input: %s validate arguments with exception: %s .\" , self . name , traceback . format_exc (), ) root = ET . Element ( \"error\" ) ET . SubElement ( root , \"message\" ) . text = str ( e ) sys . stderr . write ( defused_et . tostring ( root )) sys . stderr . flush () return 1 else : logging . error ( 'Modular input: %s run with invalid arguments: \" %s \".' , self . name , \" \" . join ( sys . argv [ 1 :]), ) return 1","title":"execute()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.extra_arguments","text":"Extra arguments for modular input. Default implementation is returning an empty list. Returns: Type Description List of arguments like : [ { 'name': 'arg1', 'title': 'arg1 title', 'description': 'arg1 description', 'validation': 'arg1 validation statement', 'data_type': Argument.data_type_string, 'required_on_edit': False, 'required_on_create': False }, {...}, {...} ] Source code in solnlib/modular_input/modular_input.py def extra_arguments ( self ) -> List : \"\"\"Extra arguments for modular input. Default implementation is returning an empty list. Returns: List of arguments like:: [ { 'name': 'arg1', 'title': 'arg1 title', 'description': 'arg1 description', 'validation': 'arg1 validation statement', 'data_type': Argument.data_type_string, 'required_on_edit': False, 'required_on_create': False }, {...}, {...} ] \"\"\" return []","title":"extra_arguments()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.get_input_definition","text":"Get input definition. This method can be overwritten to get input definition from other input instead stdin . Returns: Type Description A dict object must contains `metadata` and `inputs` : example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, inputs: { 'stanza1': {'arg1': value1, 'arg2': value2}, 'stanza2': {'arg1': value1, 'arg2': value2} } } Source code in solnlib/modular_input/modular_input.py def get_input_definition ( self ) -> dict : \"\"\"Get input definition. This method can be overwritten to get input definition from other input instead `stdin`. Returns: A dict object must contains `metadata` and `inputs`:: example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, inputs: { 'stanza1': {'arg1': value1, 'arg2': value2}, 'stanza2': {'arg1': value1, 'arg2': value2} } } \"\"\" input_definition = InputDefinition . parse ( sys . stdin ) return { \"metadata\" : input_definition . metadata , \"inputs\" : input_definition . inputs , }","title":"get_input_definition()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.get_validation_definition","text":"Get validation definition. This method can be overwritten to get validation definition from other input instead stdin . Returns: Type Description A dict object must contains `metadata` and `parameters` : example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, parameters: {'args1': value1, 'args2': value2} } Source code in solnlib/modular_input/modular_input.py def get_validation_definition ( self ) -> dict : \"\"\"Get validation definition. This method can be overwritten to get validation definition from other input instead `stdin`. Returns: A dict object must contains `metadata` and `parameters`:: example: { 'metadata': { 'session_key': 'iCKPS0cvmpyeJk...sdaf', 'server_host': 'test-test.com', 'server_uri': 'https://127.0.0.1:8089', 'checkpoint_dir': '/tmp' }, parameters: {'args1': value1, 'args2': value2} } \"\"\" validation_definition = ValidationDefinition . parse ( sys . stdin ) return { \"metadata\" : validation_definition . metadata , \"parameters\" : validation_definition . parameters , }","title":"get_validation_definition()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.register_orphan_handler","text":"Register orphan process handler. Parameters: Name Type Description Default handler Callable Teardown signal handler. required args Arguments to the handler. () Examples: >>> mi = ModularInput ( ... ) >>> def orphan_handler ( arg1 , arg2 , ... ): >>> ... >>> mi . register_orphan_handler ( orphan_handler , arg1 , arg2 , ... ) Source code in solnlib/modular_input/modular_input.py def register_orphan_handler ( self , handler : Callable , * args ): \"\"\"Register orphan process handler. Arguments: handler: Teardown signal handler. args: Arguments to the handler. Examples: >>> mi = ModularInput(...) >>> def orphan_handler(arg1, arg2, ...): >>> ... >>> mi.register_orphan_handler(orphan_handler, arg1, arg2, ...) \"\"\" def _orphan_handler (): handler ( * args ) if self . _orphan_monitor is None : self . _orphan_monitor = OrphanProcessMonitor ( _orphan_handler ) self . _orphan_monitor . start ()","title":"register_orphan_handler()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.register_teardown_handler","text":"Register teardown signal handler. Parameters: Name Type Description Default handler Callable Teardown signal handler. required args Arguments to the handler. () Examples: >>> mi = ModularInput ( ... ) >>> def teardown_handler ( arg1 , arg2 , ... ): >>> ... >>> mi . register_teardown_handler ( teardown_handler , arg1 , arg2 , ... ) Source code in solnlib/modular_input/modular_input.py def register_teardown_handler ( self , handler : Callable , * args ): \"\"\"Register teardown signal handler. Arguments: handler: Teardown signal handler. args: Arguments to the handler. Examples: >>> mi = ModularInput(...) >>> def teardown_handler(arg1, arg2, ...): >>> ... >>> mi.register_teardown_handler(teardown_handler, arg1, arg2, ...) \"\"\" def _teardown_handler ( signum , frame ): handler ( * args ) utils . handle_teardown_signals ( _teardown_handler )","title":"register_teardown_handler()"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInputException","text":"Exception for ModularInput class.","title":"ModularInputException"}]}